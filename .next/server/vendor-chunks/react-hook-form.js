"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hook-form";
exports.ids = ["vendor-chunks/react-hook-form"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FormProvider: () => (/* binding */ FormProvider),\n/* harmony export */   FormStateSubscribe: () => (/* binding */ FormStateSubscribe),\n/* harmony export */   Watch: () => (/* binding */ Watch),\n/* harmony export */   appendErrors: () => (/* binding */ appendErrors),\n/* harmony export */   createFormControl: () => (/* binding */ createFormControl),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   useController: () => (/* binding */ useController),\n/* harmony export */   useFieldArray: () => (/* binding */ useFieldArray),\n/* harmony export */   useForm: () => (/* binding */ useForm),\n/* harmony export */   useFormContext: () => (/* binding */ useFormContext),\n/* harmony export */   useFormState: () => (/* binding */ useFormState),\n/* harmony export */   useWatch: () => (/* binding */ useWatch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  false && 0;\nfunction cloneObject(data) {\n    if (data instanceof Date) {\n        return new Date(data);\n    }\n    const isFileListInstance = typeof FileList !== \"undefined\" && data instanceof FileList;\n    if (isWeb && (data instanceof Blob || isFileListInstance)) {\n        return data;\n    }\n    const isArray = Array.isArray(data);\n    if (!isArray && !(isObject(data) && isPlainObject(data))) {\n        return data;\n    }\n    const copy = isArray ? [] : Object.create(Object.getPrototypeOf(data));\n    for(const key in data){\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n            copy[key] = cloneObject(data[key]);\n        }\n    }\n    return copy;\n}\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar isUndefined = (val)=>val === undefined;\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nvar get = (object, path, defaultValue)=>{\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = (isKey(path) ? [\n        path\n    ] : stringToPath(path)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar set = (object, path, value1)=>{\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n            return;\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n};\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\n/**\n * Separate context for `control` to prevent unnecessary rerenders.\n * Internal hooks that only need control use this instead of full form context.\n */ const HookFormControlContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nHookFormControlContext.displayName = \"HookFormControlContext\";\n/**\n * @internal Internal hook to access only control from context.\n */ const useFormControlContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormControlContext);\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true)=>{\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    const formControl = useFormControlContext();\n    const { control = formControl, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        validatingFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    useIsomorphicLayoutEffect(()=>control._subscribe({\n            name,\n            formState: _localProxyFormState.current,\n            exact,\n            callback: (formState)=>{\n                !disabled && updateFormState({\n                    ...control._formState,\n                    ...formState\n                });\n            }\n        }), [\n        name,\n        disabled,\n        exact\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _localProxyFormState.current.isValid && control._setValid(true);\n    }, [\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>getProxyFormState(formState, control, _localProxyFormState.current, false), [\n        formState,\n        control\n    ]);\n}\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2, _internal_visited = new WeakSet()) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return Object.is(object1, object2);\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return Object.is(object1.getTime(), object2.getTime());\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    if (_internal_visited.has(object1) || _internal_visited.has(object2)) {\n        return true;\n    }\n    _internal_visited.add(object1);\n    _internal_visited.add(object2);\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2, _internal_visited) : !Object.is(val1, val2)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    const formControl = useFormControlContext();\n    const { control = formControl, name, defaultValue, disabled, exact, compute } = props || {};\n    const _defaultValue = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultValue);\n    const _compute = react__WEBPACK_IMPORTED_MODULE_0__.useRef(compute);\n    const _computeFormValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _prevControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control);\n    const _prevName = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _compute.current = compute;\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        const defaultValue = control._getWatch(name, _defaultValue.current);\n        return _compute.current ? _compute.current(defaultValue) : defaultValue;\n    });\n    const getCurrentOutput = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((values)=>{\n        const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);\n        return _compute.current ? _compute.current(formValues) : formValues;\n    }, [\n        control._formValues,\n        control._names,\n        name\n    ]);\n    const refreshValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((values)=>{\n        if (!disabled) {\n            const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);\n            if (_compute.current) {\n                const computedFormValues = _compute.current(formValues);\n                if (!deepEqual(computedFormValues, _computeFormValues.current)) {\n                    updateValue(computedFormValues);\n                    _computeFormValues.current = computedFormValues;\n                }\n            } else {\n                updateValue(formValues);\n            }\n        }\n    }, [\n        control._formValues,\n        control._names,\n        disabled,\n        name\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (_prevControl.current !== control || !deepEqual(_prevName.current, name)) {\n            _prevControl.current = control;\n            _prevName.current = name;\n            refreshValue();\n        }\n        return control._subscribe({\n            name,\n            formState: {\n                values: true\n            },\n            exact,\n            callback: (formState)=>{\n                refreshValue(formState.values);\n            }\n        });\n    }, [\n        control,\n        exact,\n        name,\n        refreshValue\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    // If name or control changed for this render, synchronously reflect the\n    // latest value so callers (like useController) see the correct value\n    // immediately on the same render.\n    // Optimize: Check control reference first before expensive deepEqual\n    const controlChanged = _prevControl.current !== control;\n    const prevName = _prevName.current;\n    // Cache the computed output to avoid duplicate calls within the same render\n    // We include shouldReturnImmediate in deps to ensure proper recomputation\n    const computedOutput = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (disabled) {\n            return null;\n        }\n        const nameChanged = !controlChanged && !deepEqual(prevName, name);\n        const shouldReturnImmediate = controlChanged || nameChanged;\n        return shouldReturnImmediate ? getCurrentOutput() : null;\n    }, [\n        disabled,\n        controlChanged,\n        name,\n        prevName,\n        getCurrentOutput\n    ]);\n    return computedOutput !== null ? computedOutput : value1;\n}\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    const formControl = useFormControlContext();\n    const { name, disabled, control = formControl, shouldUnregister, defaultValue, exact = true } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const defaultValueMemo = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [\n        control,\n        name,\n        defaultValue\n    ]);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: defaultValueMemo,\n        exact\n    });\n    const formState = useFormState({\n        control,\n        name,\n        exact\n    });\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    const _previousNameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1,\n        ...isBoolean(props.disabled) ? {\n            disabled: props.disabled\n        } : {}\n    }));\n    _props.current = props;\n    const fieldState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            isValidating: {\n                enumerable: true,\n                get: ()=>!!get(formState.validatingFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        }), [\n        formState,\n        name\n    ]);\n    const onChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n            target: {\n                value: getEventValue(event),\n                name: name\n            },\n            type: EVENTS.CHANGE\n        }), [\n        name\n    ]);\n    const onBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n            target: {\n                value: get(control._formValues, name),\n                name: name\n            },\n            type: EVENTS.BLUR\n        }), [\n        name,\n        control._formValues\n    ]);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((elm)=>{\n        const field = get(control._fields, name);\n        if (field && field._f && elm) {\n            field._f.ref = {\n                focus: ()=>isFunction(elm.focus) && elm.focus(),\n                select: ()=>isFunction(elm.select) && elm.select(),\n                setCustomValidity: (message)=>isFunction(elm.setCustomValidity) && elm.setCustomValidity(message),\n                reportValidity: ()=>isFunction(elm.reportValidity) && elm.reportValidity()\n            };\n        }\n    }, [\n        control._fields,\n        name\n    ]);\n    const field = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            name,\n            value: value1,\n            ...isBoolean(disabled) || formState.disabled ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange,\n            onBlur,\n            ref\n        }), [\n        name,\n        disabled,\n        formState.disabled,\n        onChange,\n        onBlur,\n        ref,\n        value1\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const previousName = _previousNameRef.current;\n        if (previousName && previousName !== name && !isArrayField) {\n            control.unregister(previousName);\n        }\n        control.register(name, {\n            ..._props.current.rules,\n            ...isBoolean(_props.current.disabled) ? {\n                disabled: _props.current.disabled\n            } : {}\n        });\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field && field._f) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name, _props.current.defaultValue));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        !isArrayField && control.register(name);\n        _previousNameRef.current = name;\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._setDisabledField({\n            disabled,\n            name\n        });\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            field,\n            formState,\n            fieldState\n        }), [\n        field,\n        formState,\n        fieldState\n    ]);\n}\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>props.render(useController(props));\nconst flatten = (obj)=>{\n    const output = {};\n    for (const key of Object.keys(obj)){\n        if (isObjectType(obj[key]) && obj[key] !== null) {\n            const nested = flatten(obj[key]);\n            for (const nestedKey of Object.keys(nested)){\n                output[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n        } else {\n            output[key] = obj[key];\n        }\n    }\n    return output;\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nHookFormContext.displayName = \"HookFormContext\";\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://react.dev/reference/react/useContext) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, watch, getValues, getFieldState, setError, clearErrors, setValue, trigger, formState, resetField, reset, handleSubmit, unregister, control, register, setFocus, subscribe } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                watch,\n                getValues,\n                getFieldState,\n                setError,\n                clearErrors,\n                setValue,\n                trigger,\n                formState,\n                resetField,\n                reset,\n                handleSubmit,\n                unregister,\n                control,\n                register,\n                setFocus,\n                subscribe\n            }), [\n            clearErrors,\n            control,\n            formState,\n            getFieldState,\n            getValues,\n            handleSubmit,\n            register,\n            reset,\n            resetField,\n            setError,\n            setFocus,\n            setValue,\n            subscribe,\n            trigger,\n            unregister,\n            watch\n        ])\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormControlContext.Provider, {\n        value: control\n    }, children));\n};\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            const flattenFormValues = flatten(control._formValues);\n            for(const key in flattenFormValues){\n                formData.append(key, flattenFormValues[key]);\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(String(action), {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType && encType !== \"multipart/form-data\" ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\nconst FormStateSubscribe = ({ control, disabled, exact, name, render })=>render(useFormState({\n        control,\n        name,\n        disabled,\n        exact\n    }));\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar createSubject = ()=>{\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n};\nfunction extractFormValues(fieldsState, formValues) {\n    const values = {};\n    for(const key in fieldsState){\n        if (fieldsState.hasOwnProperty(key)) {\n            const fieldState = fieldsState[key];\n            const fieldValue = formValues[key];\n            if (fieldState && isObject(fieldState) && fieldValue) {\n                const nestedFieldsState = extractFormValues(fieldState, fieldValue);\n                if (isObject(nestedFieldsState)) {\n                    values[key] = nestedFieldsState;\n                }\n            } else if (fieldsState[key]) {\n                values[key] = fieldValue;\n            }\n        }\n    }\n    return values;\n}\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar isFileInput = (element)=>element.type === \"file\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMultipleSelect = (element)=>element.type === `select-multiple`;\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction isTraversable(value1) {\n    return Array.isArray(value1) || isObject(value1) && !objectHasFunction(value1);\n}\nfunction markFieldsDirty(data, fields = {}) {\n    for(const key in data){\n        const value1 = data[key];\n        if (isTraversable(value1)) {\n            fields[key] = Array.isArray(value1) ? [] : {};\n            markFieldsDirty(value1, fields[key]);\n        } else if (!isUndefined(value1)) {\n            fields[key] = true;\n        }\n    }\n    return fields;\n}\nfunction getDirtyFields(data, formValues, dirtyFieldsFromValues) {\n    if (!dirtyFieldsFromValues) {\n        dirtyFieldsFromValues = markFieldsDirty(formValues);\n    }\n    for(const key in data){\n        const value1 = data[key];\n        if (isTraversable(value1)) {\n            if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                dirtyFieldsFromValues[key] = markFieldsDirty(value1, Array.isArray(value1) ? [] : {});\n            } else {\n                getDirtyFields(value1, isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n            }\n        } else {\n            const formValue = formValues[key];\n            dirtyFieldsFromValues[key] = !deepEqual(value1, formValue);\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nvar getFieldValueAs = (value1, { valueAsNumber, valueAsDate, setValueAs })=>isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map(({ value: value1 })=>value1);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar isRegex = (value1)=>value1 instanceof RegExp;\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nconst ASYNC_FUNCTION = \"AsyncFunction\";\nvar hasPromiseValidation = (fieldReference)=>!!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction)=>validateFunction.constructor.name === ASYNC_FUNCTION));\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    return true;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    return true;\n                } else {\n                    if (iterateFieldsByAction(currentField, action)) {\n                        break;\n                    }\n                }\n            } else if (isObject(currentField)) {\n                if (iterateFieldsByAction(currentField, action)) {\n                    break;\n                }\n            }\n        }\n    }\n    return;\n};\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        if (foundError && foundError.root && foundError.root.type) {\n            return {\n                name: `${fieldName}.root`,\n                error: foundError.root\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = convertToArrayPayload(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nfunction getValidateError(result, ref, type = \"validate\") {\n    if (isString(result) || Array.isArray(result) && result.every(isString) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isString(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabledFieldNames.has(name)) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength)=>{\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isString(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl(props = {}) {\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isReady: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        validatingFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false,\n        keepIsValid: false\n    };\n    let _names = {\n        mount: new Set(),\n        disabled: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const defaultProxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        validatingFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    const _proxyFormState = {\n        ...defaultProxyFormState\n    };\n    let _proxySubscribeFormState = {\n        ..._proxyFormState\n    };\n    const _subjects = {\n        array: createSubject(),\n        state: createSubject()\n    };\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _setValid = async (shouldUpdateValid)=>{\n        if (_state.keepIsValid) {\n            return;\n        }\n        if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {\n            let isValid;\n            if (_options.resolver) {\n                isValid = isEmptyObject((await _runSchema()).errors);\n                _updateIsValidating();\n            } else {\n                isValid = await executeBuiltInValidation(_fields, true);\n            }\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (names, isValidating)=>{\n        if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {\n            (names || Array.from(_names.mount)).forEach((name)=>{\n                if (name) {\n                    isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);\n                }\n            });\n            _subjects.state.next({\n                validatingFields: _formState.validatingFields,\n                isValidating: !isEmptyObject(_formState.validatingFields)\n            });\n        }\n    };\n    const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true)=>{\n        if (args && method && !_options.disabled) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const _setErrors = (errors)=>{\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && !_state.action && _setValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        if (!_options.disabled) {\n            if (!isBlurEvent || shouldDirty) {\n                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {\n                    isPreviousDirty = _formState.isDirty;\n                    _formState.isDirty = output.isDirty = _getDirty();\n                    shouldUpdateField = isPreviousDirty !== output.isDirty;\n                }\n                const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);\n                isPreviousDirty = !!get(_formState.dirtyFields, name);\n                isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n                output.dirtyFields = _formState.dirtyFields;\n                shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;\n            }\n            if (isBlurEvent) {\n                const isPreviousFieldTouched = get(_formState.touchedFields, name);\n                if (!isPreviousFieldTouched) {\n                    set(_formState.touchedFields, name, isBlurEvent);\n                    output.touchedFields = _formState.touchedFields;\n                    shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;\n                }\n            }\n            shouldUpdateField && shouldRender && _subjects.state.next(output);\n        }\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (_options.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(_options.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n    };\n    const _runSchema = async (name)=>{\n        _updateIsValidating(name, true);\n        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n        return result;\n    };\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _runSchema(names);\n        _updateIsValidating(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true\n    })=>{\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ], true);\n                    }\n                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ]);\n                    }\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid || props.shouldUseNativeValidation) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>!_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.forEach((checkboxRef)=>{\n                            if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {\n                                if (Array.isArray(fieldValue)) {\n                                    checkboxRef.checked = !!fieldValue.find((data)=>data === checkboxRef.value);\n                                } else {\n                                    checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;\n                                }\n                            }\n                        });\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.state.next({\n                            name,\n                            values: cloneObject(_formValues)\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            if (!value1.hasOwnProperty(fieldKey)) {\n                return;\n            }\n            const fieldValue = value1[fieldKey];\n            const fieldName = name + \".\" + fieldKey;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: cloneObject(_formValues)\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        if (isWatched(name, _names)) {\n            _subjects.state.next({\n                ..._formState,\n                name,\n                values: cloneObject(_formValues)\n            });\n        } else {\n            _subjects.state.next({\n                name: _state.mount ? name : undefined,\n                values: cloneObject(_formValues)\n            });\n        }\n    };\n    const onChange = async (event)=>{\n        _state.mount = true;\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));\n        };\n        const validationModeBeforeSubmit = getValidationModes(_options.mode);\n        const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                if (!target || !target.readOnly) {\n                    field._f.onBlur && field._f.onBlur(event);\n                    delayErrorCallback && delayErrorCallback(0);\n                }\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.state.next({\n                name,\n                type: event.type,\n                values: cloneObject(_formValues)\n            });\n            if (shouldSkipValidation) {\n                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                    if (_options.mode === \"onBlur\") {\n                        if (isBlurEvent) {\n                            _setValid();\n                        }\n                    } else if (!isBlurEvent) {\n                        _setValid();\n                    }\n                }\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            if (_options.resolver) {\n                const { errors } = await _runSchema([\n                    name\n                ]);\n                _updateIsValidating([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                _updateIsValidating([\n                    name\n                ], true);\n                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsValidating([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && (!Array.isArray(field._f.deps) || field._f.deps.length > 0) && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {})=>{\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _setValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames, config)=>{\n        let values = {\n            ..._state.mount ? _formValues : _defaultValues\n        };\n        if (config) {\n            values = extractFormValues(config.dirtyFields ? _formState.dirtyFields : _formState.touchedFields, values);\n        }\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            error: get((formState || _formState).errors, name),\n            isValidating: !!get(_formState.validatingFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        const currentError = get(_formState.errors, name) || {};\n        // Don't override existing error messages elsewhere in the object tree.\n        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;\n        set(_formState.errors, name, {\n            ...restOfErrorTree,\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.state.subscribe({\n            next: (payload)=>\"values\" in payload && name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const _subscribe = (props)=>_subjects.state.subscribe({\n            next: (formState)=>{\n                if (shouldSubscribeByName(props.name, formState.name, props.exact) && shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {\n                    props.callback({\n                        values: {\n                            ..._formValues\n                        },\n                        ..._formState,\n                        ...formState,\n                        defaultValues: _defaultValues\n                    });\n                }\n            }\n        }).unsubscribe;\n    const subscribe = (props)=>{\n        _state.mount = true;\n        _proxySubscribeFormState = {\n            ..._proxySubscribeFormState,\n            ...props.formState\n        };\n        return _subscribe({\n            ...props,\n            formState: {\n                ...defaultProxyFormState,\n                ...props.formState\n            }\n        });\n    };\n    const unregister = (name, options = {})=>{\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !options.keepIsValidating && unset(_formState.validatingFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.state.next({\n            values: cloneObject(_formValues)\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _setValid();\n    };\n    const _setDisabledField = ({ disabled, name })=>{\n        if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {\n            const wasDisabled = _names.disabled.has(name);\n            const isDisabled = !!disabled;\n            const disabledStateChanged = wasDisabled !== isDisabled;\n            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);\n            disabledStateChanged && _state.mount && !_state.action && _setValid();\n        }\n    };\n    const register = (name, options = {})=>{\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _setDisabledField({\n                disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,\n                name\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled || _options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref, name)=>{\n                const currentField = get(_fields, name);\n                if (currentField) {\n                    ref.disabled = currentField._f.disabled || disabled;\n                    if (Array.isArray(currentField._f.refs)) {\n                        currentField._f.refs.forEach((inputRef)=>{\n                            inputRef.disabled = currentField._f.disabled || disabled;\n                        });\n                    }\n                }\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            let onValidError = undefined;\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _runSchema();\n                _updateIsValidating();\n                _formState.errors = errors;\n                fieldValues = cloneObject(values);\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            if (_names.disabled.size) {\n                for (const name of _names.disabled){\n                    unset(fieldValues, name);\n                }\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                try {\n                    await onValid(fieldValues, e);\n                } catch (error) {\n                    onValidError = error;\n                }\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n            if (onValidError) {\n                throw onValidError;\n            }\n        };\n    const resetField = (name, options = {})=>{\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _setValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {})=>{\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const isEmptyResetValues = isEmptyObject(formValues);\n        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                const fieldsToCheck = new Set([\n                    ..._names.mount,\n                    ...Object.keys(getDirtyFields(_defaultValues, _formValues))\n                ]);\n                for (const fieldName of Array.from(fieldsToCheck)){\n                    const isDirty = get(_formState.dirtyFields, fieldName);\n                    const existingValue = get(_formValues, fieldName);\n                    const newValue = get(values, fieldName);\n                    if (isDirty && !isUndefined(existingValue)) {\n                        set(values, fieldName, existingValue);\n                    } else if (!isDirty && !isUndefined(newValue)) {\n                        setValue(fieldName, newValue);\n                    }\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (keepStateOptions.keepFieldsRef) {\n                    for (const fieldName of _names.mount){\n                        setValue(fieldName, get(values, fieldName));\n                    }\n                } else {\n                    _fields = {};\n                }\n            }\n            _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.state.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            disabled: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues || !_options.shouldUnregister && !isEmptyObject(values);\n        _state.watch = !!_options.shouldUnregister;\n        _state.keepIsValid = !!keepStateOptions.keepIsValid;\n        _state.action = false;\n        // Clear errors synchronously to prevent validation errors on subsequent submissions\n        // This fixes the issue where form.reset() causes validation errors on subsequent\n        // submissions in Next.js 16 with Server Actions\n        if (!keepStateOptions.keepErrors) {\n            _formState.errors = {};\n        }\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false,\n            defaultValues: _defaultValues\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, {\n            ..._options.resetOptions,\n            ...keepStateOptions\n        });\n    const setFocus = (name, options = {})=>{\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                // Use setTimeout to ensure focus happens after any pending state updates\n                // This fixes the issue where setFocus doesn't work immediately after setError\n                setTimeout(()=>{\n                    fieldRef.focus();\n                    options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();\n                });\n            }\n        }\n    };\n    const _setFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    const methods = {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _subscribe,\n            _runSchema,\n            _updateIsValidating,\n            _focusError,\n            _getWatch,\n            _getDirty,\n            _setValid,\n            _setFieldArray,\n            _setDisabledField,\n            _setErrors,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _removeUnmounted,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        subscribe,\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n    return {\n        ...methods,\n        formControl: methods\n    };\n}\nvar generateId = ()=>{\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = (name, index, options = {})=>options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : \"\";\nvar appendAt = (data, value1)=>[\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nvar prependAt = (data, value1)=>[\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    [data[indexA], data[indexB]] = [\n        data[indexB],\n        data[indexA]\n    ];\n};\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    const formControl = useFormControlContext();\n    const { control = formControl, name, keyName = \"id\", shouldUnregister, rules } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    control._names.array.add(name);\n    react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>rules && fields.length >= 0 && control.register(name, rules), [\n        control,\n        name,\n        fields.length,\n        rules\n    ]);\n    useIsomorphicLayoutEffect(()=>control._subjects.array.subscribe({\n            next: ({ values, name: fieldArrayName })=>{\n                if (fieldArrayName === name || !fieldArrayName) {\n                    const fieldValues = get(values, name);\n                    if (Array.isArray(fieldValues)) {\n                        setFields(fieldValues);\n                        ids.current = fieldValues.map(generateId);\n                    }\n                }\n            }\n        }).unsubscribe, [\n        control,\n        name\n    ]);\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._setFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        !Array.isArray(get(control._fields, name)) && set(control._fields, name, undefined);\n        control._setFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted) && !getValidationModes(control._options.reValidateMode).isOnSubmit) {\n            if (control._options.resolver) {\n                control._runSchema([\n                    name\n                ]).then((result)=>{\n                    control._updateIsValidating([\n                        name\n                    ]);\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.state.next({\n            name,\n            values: cloneObject(control._formValues)\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._setValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._setFieldArray(name);\n        return ()=>{\n            const updateMounted = (name, value1)=>{\n                const field = get(control._fields, name);\n                if (field && field._f) {\n                    field._f.mount = value1;\n                }\n            };\n            control._options.shouldUnregister || shouldUnregister ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        validatingFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        isReady: false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        if (props.formControl) {\n            _formControl.current = {\n                ...props.formControl,\n                formState\n            };\n            if (props.defaultValues && !isFunction(props.defaultValues)) {\n                props.formControl.reset(props.defaultValues, props.resetOptions);\n            }\n        } else {\n            const { formControl, ...rest } = createFormControl(props);\n            _formControl.current = {\n                ...rest,\n                formState\n            };\n        }\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useIsomorphicLayoutEffect(()=>{\n        const sub = control._subscribe({\n            formState: control._proxyFormState,\n            callback: ()=>updateFormState({\n                    ...control._formState\n                }),\n            reRenderRoot: true\n        });\n        updateFormState((data)=>({\n                ...data,\n                isReady: true\n            }));\n        control._formState.isReady = true;\n        return sub;\n    }, [\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.mode) {\n            control._options.mode = props.mode;\n        }\n        if (props.reValidateMode) {\n            control._options.reValidateMode = props.reValidateMode;\n        }\n    }, [\n        control,\n        props.mode,\n        props.reValidateMode\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.errors) {\n            control._setErrors(props.errors);\n            control._focusError();\n        }\n    }, [\n        control,\n        props.errors\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        props.shouldUnregister && control._subjects.state.next({\n            values: control._getWatch()\n        });\n    }, [\n        control,\n        props.shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _a;\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, {\n                keepFieldsRef: true,\n                ...control._options.resetOptions\n            });\n            if (!((_a = control._options.resetOptions) === null || _a === void 0 ? void 0 : _a.keepIsValid)) {\n                control._setValid();\n            }\n            _values.current = props.values;\n            updateFormState((state)=>({\n                    ...state\n                }));\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        control,\n        props.values\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._setValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    _formControl.current.formState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>getProxyFormState(formState, control), [\n        control,\n        formState\n    ]);\n    return _formControl.current;\n}\n/**\n * Watch component that subscribes to form field changes and re-renders when watched fields update.\n *\n * @param control - The form control object from useForm\n * @param name - Can be field name, array of field names, or undefined to watch the entire form\n * @param disabled - Disable subscription\n * @param exact - Whether to watch exact field names or not\n * @param defaultValue - The default value to use if the field is not yet set\n * @param compute - Function to compute derived values from watched fields\n * @param render - The function that receives watched values and returns ReactNode\n * @returns The result of calling render function with watched values\n *\n * @example\n * The `Watch` component only re-render when the values of `foo`, `bar`, and `baz.qux` change.\n * The types of `foo`, `bar`, and `baz.qux` are precisely inferred.\n *\n * ```tsx\n * const { control } = useForm();\n *\n * <Watch\n *   control={control}\n *   names={['foo', 'bar', 'baz.qux']}\n *   render={([foo, bar, baz_qux]) => <div>{foo}{bar}{baz_qux}</div>}\n * />\n * ```\n */ const Watch = (props)=>props.render(useWatch({\n        name: props.names,\n        ...props\n    }));\n //# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBRTFCLElBQUlDLGtCQUFrQixDQUFDQyxVQUFZQSxRQUFRQyxJQUFJLEtBQUs7QUFFcEQsSUFBSUMsZUFBZSxDQUFDQyxTQUFVQSxrQkFBaUJDO0FBRS9DLElBQUlDLG9CQUFvQixDQUFDRixTQUFVQSxVQUFTO0FBRTVDLE1BQU1HLGVBQWUsQ0FBQ0gsU0FBVSxPQUFPQSxXQUFVO0FBQ2pELElBQUlJLFdBQVcsQ0FBQ0osU0FBVSxDQUFDRSxrQkFBa0JGLFdBQ3pDLENBQUNLLE1BQU1DLE9BQU8sQ0FBQ04sV0FDZkcsYUFBYUgsV0FDYixDQUFDRCxhQUFhQztBQUVsQixJQUFJTyxnQkFBZ0IsQ0FBQ0MsUUFBVUosU0FBU0ksVUFBVUEsTUFBTUMsTUFBTSxHQUN4RGIsZ0JBQWdCWSxNQUFNQyxNQUFNLElBQ3hCRCxNQUFNQyxNQUFNLENBQUNDLE9BQU8sR0FDcEJGLE1BQU1DLE1BQU0sQ0FBQ1QsS0FBSyxHQUN0QlE7QUFFTixJQUFJRyxvQkFBb0IsQ0FBQ0MsT0FBU0EsS0FBS0MsU0FBUyxDQUFDLEdBQUdELEtBQUtFLE1BQU0sQ0FBQyxtQkFBbUJGO0FBRW5GLElBQUlHLHFCQUFxQixDQUFDQyxPQUFPSixPQUFTSSxNQUFNQyxHQUFHLENBQUNOLGtCQUFrQkM7QUFFdEUsSUFBSU0sZ0JBQWdCLENBQUNDO0lBQ2pCLE1BQU1DLGdCQUFnQkQsV0FBV0UsV0FBVyxJQUFJRixXQUFXRSxXQUFXLENBQUNDLFNBQVM7SUFDaEYsT0FBUWxCLFNBQVNnQixrQkFBa0JBLGNBQWNHLGNBQWMsQ0FBQztBQUNwRTtBQUVBLElBQUlDLFFBQVEsTUFDc0IsSUFDOUIsQ0FBb0I7QUFFeEIsU0FBU0ksWUFBWUMsSUFBSTtJQUNyQixJQUFJQSxnQkFBZ0I1QixNQUFNO1FBQ3RCLE9BQU8sSUFBSUEsS0FBSzRCO0lB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QnJELGdCQUFnQixDQUFDd0osUUFBVztvQkFBRSxHQUFHQSxLQUFLO2dCQUFDO1FBQzNDLE9BQ0s7WUFDRHhLLFFBQVE4YixtQkFBbUI7UUFDL0I7SUFDSixHQUFHO1FBQUM5YjtRQUFTWSxNQUFNeUQsTUFBTTtLQUFDO0lBQzFCdEssNENBQWUsQ0FBQztRQUNaLElBQUksQ0FBQ2lHLFFBQVErRyxNQUFNLENBQUNELEtBQUssRUFBRTtZQUN2QjlHLFFBQVFnQyxTQUFTO1lBQ2pCaEMsUUFBUStHLE1BQU0sQ0FBQ0QsS0FBSyxHQUFHO1FBQzNCO1FBQ0EsSUFBSTlHLFFBQVErRyxNQUFNLENBQUN4RSxLQUFLLEVBQUU7WUFDdEJ2QyxRQUFRK0csTUFBTSxDQUFDeEUsS0FBSyxHQUFHO1lBQ3ZCdkMsUUFBUXVLLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUM7Z0JBQUUsR0FBR3pLLFFBQVFrQixVQUFVO1lBQUM7UUFDekQ7UUFDQWxCLFFBQVF5RSxnQkFBZ0I7SUFDNUI7SUFDQTRhLGFBQWF2ZCxPQUFPLENBQUMvQixTQUFTLEdBQUdoRywwQ0FBYSxDQUFDLElBQU0rRixrQkFBa0JDLFdBQVdDLFVBQVU7UUFBQ0E7UUFBU0Q7S0FBVTtJQUNoSCxPQUFPc2YsYUFBYXZkLE9BQU87QUFDL0I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELE1BQU0wZCxRQUFRLENBQUM1ZSxRQUFVQSxNQUFNdUcsTUFBTSxDQUFDekQsU0FBUztRQUFFMUksTUFBTTRGLE1BQU14RixLQUFLO1FBQUUsR0FBR3dGLEtBQUs7SUFBQztBQUVrSCxDQUMvTCxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmlycy1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcz85ZGMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnZhciBpc0NoZWNrQm94SW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnY2hlY2tib3gnO1xuXG52YXIgaXNEYXRlT2JqZWN0ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG5cbnZhciBpc051bGxPclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT0gbnVsbDtcblxuY29uc3QgaXNPYmplY3RUeXBlID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xudmFyIGlzT2JqZWN0ID0gKHZhbHVlKSA9PiAhaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpICYmXG4gICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgaXNPYmplY3RUeXBlKHZhbHVlKSAmJlxuICAgICFpc0RhdGVPYmplY3QodmFsdWUpO1xuXG52YXIgZ2V0RXZlbnRWYWx1ZSA9IChldmVudCkgPT4gaXNPYmplY3QoZXZlbnQpICYmIGV2ZW50LnRhcmdldFxuICAgID8gaXNDaGVja0JveElucHV0KGV2ZW50LnRhcmdldClcbiAgICAgICAgPyBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICA6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIDogZXZlbnQ7XG5cbnZhciBnZXROb2RlUGFyZW50TmFtZSA9IChuYW1lKSA9PiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLnNlYXJjaCgvXFwuXFxkKyhcXC58JCkvKSkgfHwgbmFtZTtcblxudmFyIGlzTmFtZUluRmllbGRBcnJheSA9IChuYW1lcywgbmFtZSkgPT4gbmFtZXMuaGFzKGdldE5vZGVQYXJlbnROYW1lKG5hbWUpKTtcblxudmFyIGlzUGxhaW5PYmplY3QgPSAodGVtcE9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb3RvdHlwZUNvcHkgPSB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yICYmIHRlbXBPYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHJldHVybiAoaXNPYmplY3QocHJvdG90eXBlQ29weSkgJiYgcHJvdG90eXBlQ29weS5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpKTtcbn07XG5cbnZhciBpc1dlYiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChkYXRhKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgaXNGaWxlTGlzdEluc3RhbmNlID0gdHlwZW9mIEZpbGVMaXN0ICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgRmlsZUxpc3Q7XG4gICAgaWYgKGlzV2ViICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBpc0ZpbGVMaXN0SW5zdGFuY2UpKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkYXRhKTtcbiAgICBpZiAoIWlzQXJyYXkgJiYgIShpc09iamVjdChkYXRhKSAmJiBpc1BsYWluT2JqZWN0KGRhdGEpKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgY29weSA9IGlzQXJyYXkgPyBbXSA6IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGRhdGEpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVPYmplY3QoZGF0YVtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cblxudmFyIGlzS2V5ID0gKHZhbHVlKSA9PiAvXlxcdyokLy50ZXN0KHZhbHVlKTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBjb21wYWN0ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKGlucHV0KSA9PiBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXXxcXF0vZywgJycpLnNwbGl0KC9cXC58XFxbLykpO1xuXG52YXIgZ2V0ID0gKG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKCFwYXRoIHx8ICFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IChpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IHJlc3VsdCA6IHJlc3VsdFtrZXldLCBvYmplY3QpO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZChyZXN1bHQpIHx8IHJlc3VsdCA9PT0gb2JqZWN0XG4gICAgICAgID8gaXNVbmRlZmluZWQob2JqZWN0W3BhdGhdKVxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgIDogb2JqZWN0W3BhdGhdXG4gICAgICAgIDogcmVzdWx0O1xufTtcblxudmFyIGlzQm9vbGVhbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cbnZhciBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbnZhciBzZXQgPSAob2JqZWN0LCBwYXRoLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gdGVtcFBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgaXNPYmplY3Qob2JqVmFsdWUpIHx8IEFycmF5LmlzQXJyYXkob2JqVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNOYU4oK3RlbXBQYXRoW2luZGV4ICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfVxufTtcblxuY29uc3QgRVZFTlRTID0ge1xuICAgIEJMVVI6ICdibHVyJyxcbiAgICBGT0NVU19PVVQ6ICdmb2N1c291dCcsXG4gICAgQ0hBTkdFOiAnY2hhbmdlJyxcbn07XG5jb25zdCBWQUxJREFUSU9OX01PREUgPSB7XG4gICAgb25CbHVyOiAnb25CbHVyJyxcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcbiAgICBvblN1Ym1pdDogJ29uU3VibWl0JyxcbiAgICBvblRvdWNoZWQ6ICdvblRvdWNoZWQnLFxuICAgIGFsbDogJ2FsbCcsXG59O1xuY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgICBtYXg6ICdtYXgnLFxuICAgIG1pbjogJ21pbicsXG4gICAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxuICAgIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcbn07XG5cbi8qKlxuICogU2VwYXJhdGUgY29udGV4dCBmb3IgYGNvbnRyb2xgIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxuICogSW50ZXJuYWwgaG9va3MgdGhhdCBvbmx5IG5lZWQgY29udHJvbCB1c2UgdGhpcyBpbnN0ZWFkIG9mIGZ1bGwgZm9ybSBjb250ZXh0LlxuICovXG5jb25zdCBIb29rRm9ybUNvbnRyb2xDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkhvb2tGb3JtQ29udHJvbENvbnRleHQuZGlzcGxheU5hbWUgPSAnSG9va0Zvcm1Db250cm9sQ29udGV4dCc7XG4vKipcbiAqIEBpbnRlcm5hbCBJbnRlcm5hbCBob29rIHRvIGFjY2VzcyBvbmx5IGNvbnRyb2wgZnJvbSBjb250ZXh0LlxuICovXG5jb25zdCB1c2VGb3JtQ29udHJvbENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEhvb2tGb3JtQ29udHJvbENvbnRleHQpO1xuXG52YXIgZ2V0UHJveHlGb3JtU3RhdGUgPSAoZm9ybVN0YXRlLCBjb250cm9sLCBsb2NhbFByb3h5Rm9ybVN0YXRlLCBpc1Jvb3QgPSB0cnVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBkZWZhdWx0VmFsdWVzOiBjb250cm9sLl9kZWZhdWx0VmFsdWVzLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZm9ybVN0YXRlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2tleSA9IGtleTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5fcHJveHlGb3JtU3RhdGVbX2tleV0gIT09IFZBTElEQVRJT05fTU9ERS5hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5fcHJveHlGb3JtU3RhdGVbX2tleV0gPSAhaXNSb290IHx8IFZBTElEQVRJT05fTU9ERS5hbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsUHJveHlGb3JtU3RhdGUgJiYgKGxvY2FsUHJveHlGb3JtU3RhdGVbX2tleV0gPSB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybVN0YXRlW19rZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBjdXN0b20gaG9vayBhbGxvd3MgeW91IHRvIHN1YnNjcmliZSB0byBlYWNoIGZvcm0gc3RhdGUsIGFuZCBpc29sYXRlIHRoZSByZS1yZW5kZXIgYXQgdGhlIGN1c3RvbSBob29rIGxldmVsLiBJdCBoYXMgaXRzIHNjb3BlIGluIHRlcm1zIG9mIGZvcm0gc3RhdGUgc3Vic2NyaXB0aW9uLCBzbyBpdCB3b3VsZCBub3QgYWZmZWN0IG90aGVyIHVzZUZvcm1TdGF0ZSBhbmQgdXNlRm9ybS4gVXNpbmcgdGhpcyBob29rIGNhbiByZWR1Y2UgdGhlIHJlLXJlbmRlciBpbXBhY3Qgb24gbGFyZ2UgYW5kIGNvbXBsZXggZm9ybSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybXN0YXRlKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy91c2Vmb3Jtc3RhdGUtNzV4bHkpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gaW5jbHVkZSBvcHRpb25zIG9uIHNwZWNpZnkgZmllbGRzIHRvIHN1YnNjcmliZS4ge0BsaW5rIFVzZUZvcm1TdGF0ZVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGhhbmRsZVN1Ym1pdCwgY29udHJvbCB9ID0gdXNlRm9ybSh7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgIGZpcnN0TmFtZTogXCJmaXJzdE5hbWVcIlxuICogICB9fSk7XG4gKiAgIGNvbnN0IHsgZGlydHlGaWVsZHMgfSA9IHVzZUZvcm1TdGF0ZSh7XG4gKiAgICAgY29udHJvbFxuICogICB9KTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSAoZGF0YSkgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJmaXJzdE5hbWVcIil9IHBsYWNlaG9sZGVyPVwiRmlyc3QgTmFtZVwiIC8+XG4gKiAgICAgICB7ZGlydHlGaWVsZHMuZmlyc3ROYW1lICYmIDxwPkZpZWxkIGlzIGRpcnR5LjwvcD59XG4gKiAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShwcm9wcykge1xuICAgIGNvbnN0IGZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2xDb250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gZm9ybUNvbnRyb2wsIGRpc2FibGVkLCBuYW1lLCBleGFjdCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGNvbnRyb2wuX2Zvcm1TdGF0ZSk7XG4gICAgY29uc3QgX2xvY2FsUHJveHlGb3JtU3RhdGUgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gY29udHJvbC5fc3Vic2NyaWJlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZm9ybVN0YXRlOiBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LFxuICAgICAgICBleGFjdCxcbiAgICAgICAgY2FsbGJhY2s6IChmb3JtU3RhdGUpID0+IHtcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pLCBbbmFtZSwgZGlzYWJsZWQsIGV4YWN0XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudC5pc1ZhbGlkICYmIGNvbnRyb2wuX3NldFZhbGlkKHRydWUpO1xuICAgIH0sIFtjb250cm9sXSk7XG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sLCBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LCBmYWxzZSksIFtmb3JtU3RhdGUsIGNvbnRyb2xdKTtcbn1cblxudmFyIGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG52YXIgZ2VuZXJhdGVXYXRjaE91dHB1dCA9IChuYW1lcywgX25hbWVzLCBmb3JtVmFsdWVzLCBpc0dsb2JhbCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKGlzU3RyaW5nKG5hbWVzKSkge1xuICAgICAgICBpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKG5hbWVzKTtcbiAgICAgICAgcmV0dXJuIGdldChmb3JtVmFsdWVzLCBuYW1lcywgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXMpKSB7XG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAoKGZpZWxkTmFtZSkgPT4gKGlzR2xvYmFsICYmIF9uYW1lcy53YXRjaC5hZGQoZmllbGROYW1lKSxcbiAgICAgICAgICAgIGdldChmb3JtVmFsdWVzLCBmaWVsZE5hbWUpKSk7XG4gICAgfVxuICAgIGlzR2xvYmFsICYmIChfbmFtZXMud2F0Y2hBbGwgPSB0cnVlKTtcbiAgICByZXR1cm4gZm9ybVZhbHVlcztcbn07XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwob2JqZWN0MSwgb2JqZWN0MiwgX2ludGVybmFsX3Zpc2l0ZWQgPSBuZXcgV2Vha1NldCgpKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdDEpIHx8IGlzUHJpbWl0aXZlKG9iamVjdDIpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuaXMob2JqZWN0MSwgb2JqZWN0Mik7XG4gICAgfVxuICAgIGlmIChpc0RhdGVPYmplY3Qob2JqZWN0MSkgJiYgaXNEYXRlT2JqZWN0KG9iamVjdDIpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuaXMob2JqZWN0MS5nZXRUaW1lKCksIG9iamVjdDIuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChfaW50ZXJuYWxfdmlzaXRlZC5oYXMob2JqZWN0MSkgfHwgX2ludGVybmFsX3Zpc2l0ZWQuaGFzKG9iamVjdDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaXRlZC5hZGQob2JqZWN0MSk7XG4gICAgX2ludGVybmFsX3Zpc2l0ZWQuYWRkKG9iamVjdDIpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gb2JqZWN0MltrZXldO1xuICAgICAgICAgICAgaWYgKChpc0RhdGVPYmplY3QodmFsMSkgJiYgaXNEYXRlT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwxKSAmJiBpc09iamVjdCh2YWwyKSkgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWwxKSAmJiBBcnJheS5pc0FycmF5KHZhbDIpKVxuICAgICAgICAgICAgICAgID8gIWRlZXBFcXVhbCh2YWwxLCB2YWwyLCBfaW50ZXJuYWxfdmlzaXRlZClcbiAgICAgICAgICAgICAgICA6ICFPYmplY3QuaXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gc3Vic2NyaWJlIHRvIGZpZWxkIGNoYW5nZSBhbmQgaXNvbGF0ZSByZS1yZW5kZXJpbmcgYXQgdGhlIGNvbXBvbmVudCBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZXdhdGNoKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctdHMtdXNld2F0Y2gtaDlpNWUpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtKCk7XG4gKiBjb25zdCB2YWx1ZXMgPSB1c2VXYXRjaCh7XG4gKiAgIG5hbWU6IFwiZmllbGROYW1lXCJcbiAqICAgY29udHJvbCxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlV2F0Y2gocHJvcHMpIHtcbiAgICBjb25zdCBmb3JtQ29udHJvbCA9IHVzZUZvcm1Db250cm9sQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IGZvcm1Db250cm9sLCBuYW1lLCBkZWZhdWx0VmFsdWUsIGRpc2FibGVkLCBleGFjdCwgY29tcHV0ZSwgfSA9IHByb3BzIHx8IHt9O1xuICAgIGNvbnN0IF9kZWZhdWx0VmFsdWUgPSBSZWFjdC51c2VSZWYoZGVmYXVsdFZhbHVlKTtcbiAgICBjb25zdCBfY29tcHV0ZSA9IFJlYWN0LnVzZVJlZihjb21wdXRlKTtcbiAgICBjb25zdCBfY29tcHV0ZUZvcm1WYWx1ZXMgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICBjb25zdCBfcHJldkNvbnRyb2wgPSBSZWFjdC51c2VSZWYoY29udHJvbCk7XG4gICAgY29uc3QgX3ByZXZOYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuICAgIF9jb21wdXRlLmN1cnJlbnQgPSBjb21wdXRlO1xuICAgIGNvbnN0IFt2YWx1ZSwgdXBkYXRlVmFsdWVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBjb250cm9sLl9nZXRXYXRjaChuYW1lLCBfZGVmYXVsdFZhbHVlLmN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gX2NvbXB1dGUuY3VycmVudCA/IF9jb21wdXRlLmN1cnJlbnQoZGVmYXVsdFZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRDdXJyZW50T3V0cHV0ID0gUmVhY3QudXNlQ2FsbGJhY2soKHZhbHVlcykgPT4ge1xuICAgICAgICBjb25zdCBmb3JtVmFsdWVzID0gZ2VuZXJhdGVXYXRjaE91dHB1dChuYW1lLCBjb250cm9sLl9uYW1lcywgdmFsdWVzIHx8IGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIGZhbHNlLCBfZGVmYXVsdFZhbHVlLmN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gX2NvbXB1dGUuY3VycmVudCA/IF9jb21wdXRlLmN1cnJlbnQoZm9ybVZhbHVlcykgOiBmb3JtVmFsdWVzO1xuICAgIH0sIFtjb250cm9sLl9mb3JtVmFsdWVzLCBjb250cm9sLl9uYW1lcywgbmFtZV0pO1xuICAgIGNvbnN0IHJlZnJlc2hWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybVZhbHVlcyA9IGdlbmVyYXRlV2F0Y2hPdXRwdXQobmFtZSwgY29udHJvbC5fbmFtZXMsIHZhbHVlcyB8fCBjb250cm9sLl9mb3JtVmFsdWVzLCBmYWxzZSwgX2RlZmF1bHRWYWx1ZS5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChfY29tcHV0ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRGb3JtVmFsdWVzID0gX2NvbXB1dGUuY3VycmVudChmb3JtVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChjb21wdXRlZEZvcm1WYWx1ZXMsIF9jb21wdXRlRm9ybVZhbHVlcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZShjb21wdXRlZEZvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBfY29tcHV0ZUZvcm1WYWx1ZXMuY3VycmVudCA9IGNvbXB1dGVkRm9ybVZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZShmb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLl9mb3JtVmFsdWVzLCBjb250cm9sLl9uYW1lcywgZGlzYWJsZWQsIG5hbWVdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKF9wcmV2Q29udHJvbC5jdXJyZW50ICE9PSBjb250cm9sIHx8XG4gICAgICAgICAgICAhZGVlcEVxdWFsKF9wcmV2TmFtZS5jdXJyZW50LCBuYW1lKSkge1xuICAgICAgICAgICAgX3ByZXZDb250cm9sLmN1cnJlbnQgPSBjb250cm9sO1xuICAgICAgICAgICAgX3ByZXZOYW1lLmN1cnJlbnQgPSBuYW1lO1xuICAgICAgICAgICAgcmVmcmVzaFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2wuX3N1YnNjcmliZSh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZm9ybVN0YXRlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4YWN0LFxuICAgICAgICAgICAgY2FsbGJhY2s6IChmb3JtU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICByZWZyZXNoVmFsdWUoZm9ybVN0YXRlLnZhbHVlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbY29udHJvbCwgZXhhY3QsIG5hbWUsIHJlZnJlc2hWYWx1ZV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBjb250cm9sLl9yZW1vdmVVbm1vdW50ZWQoKSk7XG4gICAgLy8gSWYgbmFtZSBvciBjb250cm9sIGNoYW5nZWQgZm9yIHRoaXMgcmVuZGVyLCBzeW5jaHJvbm91c2x5IHJlZmxlY3QgdGhlXG4gICAgLy8gbGF0ZXN0IHZhbHVlIHNvIGNhbGxlcnMgKGxpa2UgdXNlQ29udHJvbGxlcikgc2VlIHRoZSBjb3JyZWN0IHZhbHVlXG4gICAgLy8gaW1tZWRpYXRlbHkgb24gdGhlIHNhbWUgcmVuZGVyLlxuICAgIC8vIE9wdGltaXplOiBDaGVjayBjb250cm9sIHJlZmVyZW5jZSBmaXJzdCBiZWZvcmUgZXhwZW5zaXZlIGRlZXBFcXVhbFxuICAgIGNvbnN0IGNvbnRyb2xDaGFuZ2VkID0gX3ByZXZDb250cm9sLmN1cnJlbnQgIT09IGNvbnRyb2w7XG4gICAgY29uc3QgcHJldk5hbWUgPSBfcHJldk5hbWUuY3VycmVudDtcbiAgICAvLyBDYWNoZSB0aGUgY29tcHV0ZWQgb3V0cHV0IHRvIGF2b2lkIGR1cGxpY2F0ZSBjYWxscyB3aXRoaW4gdGhlIHNhbWUgcmVuZGVyXG4gICAgLy8gV2UgaW5jbHVkZSBzaG91bGRSZXR1cm5JbW1lZGlhdGUgaW4gZGVwcyB0byBlbnN1cmUgcHJvcGVyIHJlY29tcHV0YXRpb25cbiAgICBjb25zdCBjb21wdXRlZE91dHB1dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVDaGFuZ2VkID0gIWNvbnRyb2xDaGFuZ2VkICYmICFkZWVwRXF1YWwocHJldk5hbWUsIG5hbWUpO1xuICAgICAgICBjb25zdCBzaG91bGRSZXR1cm5JbW1lZGlhdGUgPSBjb250cm9sQ2hhbmdlZCB8fCBuYW1lQ2hhbmdlZDtcbiAgICAgICAgcmV0dXJuIHNob3VsZFJldHVybkltbWVkaWF0ZSA/IGdldEN1cnJlbnRPdXRwdXQoKSA6IG51bGw7XG4gICAgfSwgW2Rpc2FibGVkLCBjb250cm9sQ2hhbmdlZCwgbmFtZSwgcHJldk5hbWUsIGdldEN1cnJlbnRPdXRwdXRdKTtcbiAgICByZXR1cm4gY29tcHV0ZWRPdXRwdXQgIT09IG51bGwgPyBjb21wdXRlZE91dHB1dCA6IHZhbHVlO1xufVxuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIHdvcmsgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhpcyBmdW5jdGlvbiBwcm92aWRlIHlvdSB3aXRoIGJvdGggZm9ybSBhbmQgZmllbGQgbGV2ZWwgc3RhdGUuIFJlLXJlbmRlciBpcyBpc29sYXRlZCBhdCB0aGUgaG9vayBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlY29udHJvbGxlci0wbzhweClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0aGUgcGF0aCBuYW1lIHRvIHRoZSBmb3JtIGZpZWxkIHZhbHVlLCBhbmQgdmFsaWRhdGlvbiBydWxlcy5cbiAqXG4gKiBAcmV0dXJucyBmaWVsZCBwcm9wZXJ0aWVzLCBmaWVsZCBhbmQgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUNvbnRyb2xsZXJSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gSW5wdXQocHJvcHMpIHtcbiAqICAgY29uc3QgeyBmaWVsZCwgZmllbGRTdGF0ZSwgZm9ybVN0YXRlIH0gPSB1c2VDb250cm9sbGVyKHByb3BzKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPGlucHV0IHsuLi5maWVsZH0gcGxhY2Vob2xkZXI9e3Byb3BzLm5hbWV9IC8+XG4gKiAgICAgICA8cD57ZmllbGRTdGF0ZS5pc1RvdWNoZWQgJiYgXCJUb3VjaGVkXCJ9PC9wPlxuICogICAgICAgPHA+e2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCA/IFwic3VibWl0dGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VDb250cm9sbGVyKHByb3BzKSB7XG4gICAgY29uc3QgZm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbENvbnRleHQoKTtcbiAgICBjb25zdCB7IG5hbWUsIGRpc2FibGVkLCBjb250cm9sID0gZm9ybUNvbnRyb2wsIHNob3VsZFVucmVnaXN0ZXIsIGRlZmF1bHRWYWx1ZSwgZXhhY3QgPSB0cnVlLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNBcnJheUZpZWxkID0gaXNOYW1lSW5GaWVsZEFycmF5KGNvbnRyb2wuX25hbWVzLmFycmF5LCBuYW1lKTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVNZW1vID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgZ2V0KGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIGRlZmF1bHRWYWx1ZSkpLCBbY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlXSk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VXYXRjaCh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlTWVtbyxcbiAgICAgICAgZXhhY3QsXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcbiAgICAgICAgY29udHJvbCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZXhhY3QsXG4gICAgfSk7XG4gICAgY29uc3QgX3Byb3BzID0gUmVhY3QudXNlUmVmKHByb3BzKTtcbiAgICBjb25zdCBfcHJldmlvdXNOYW1lUmVmID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgX3JlZ2lzdGVyUHJvcHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgIC4uLnByb3BzLnJ1bGVzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihwcm9wcy5kaXNhYmxlZCkgPyB7IGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB9IDoge30pLFxuICAgIH0pKTtcbiAgICBfcHJvcHMuY3VycmVudCA9IHByb3BzO1xuICAgIGNvbnN0IGZpZWxkU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gICAgICAgIGludmFsaWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc0RpcnR5OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc1RvdWNoZWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgfSksIFtmb3JtU3RhdGUsIG5hbWVdKTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkNoYW5nZSh7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldEV2ZW50VmFsdWUoZXZlbnQpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogRVZFTlRTLkNIQU5HRSxcbiAgICB9KSwgW25hbWVdKTtcbiAgICBjb25zdCBvbkJsdXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQmx1cih7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IEVWRU5UUy5CTFVSLFxuICAgIH0pLCBbbmFtZSwgY29udHJvbC5fZm9ybVZhbHVlc10pO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKChlbG0pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mICYmIGVsbSkge1xuICAgICAgICAgICAgZmllbGQuX2YucmVmID0ge1xuICAgICAgICAgICAgICAgIGZvY3VzOiAoKSA9PiBpc0Z1bmN0aW9uKGVsbS5mb2N1cykgJiYgZWxtLmZvY3VzKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0OiAoKSA9PiBpc0Z1bmN0aW9uKGVsbS5zZWxlY3QpICYmIGVsbS5zZWxlY3QoKSxcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eTogKG1lc3NhZ2UpID0+IGlzRnVuY3Rpb24oZWxtLnNldEN1c3RvbVZhbGlkaXR5KSAmJiBlbG0uc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgcmVwb3J0VmFsaWRpdHk6ICgpID0+IGlzRnVuY3Rpb24oZWxtLnJlcG9ydFZhbGlkaXR5KSAmJiBlbG0ucmVwb3J0VmFsaWRpdHkoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbC5fZmllbGRzLCBuYW1lXSk7XG4gICAgY29uc3QgZmllbGQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAuLi4oaXNCb29sZWFuKGRpc2FibGVkKSB8fCBmb3JtU3RhdGUuZGlzYWJsZWRcbiAgICAgICAgICAgID8geyBkaXNhYmxlZDogZm9ybVN0YXRlLmRpc2FibGVkIHx8IGRpc2FibGVkIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgb25CbHVyLFxuICAgICAgICByZWYsXG4gICAgfSksIFtuYW1lLCBkaXNhYmxlZCwgZm9ybVN0YXRlLmRpc2FibGVkLCBvbkNoYW5nZSwgb25CbHVyLCByZWYsIHZhbHVlXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCA9IGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBzaG91bGRVbnJlZ2lzdGVyO1xuICAgICAgICBjb25zdCBwcmV2aW91c05hbWUgPSBfcHJldmlvdXNOYW1lUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChwcmV2aW91c05hbWUgJiYgcHJldmlvdXNOYW1lICE9PSBuYW1lICYmICFpc0FycmF5RmllbGQpIHtcbiAgICAgICAgICAgIGNvbnRyb2wudW5yZWdpc3RlcihwcmV2aW91c05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXIobmFtZSwge1xuICAgICAgICAgICAgLi4uX3Byb3BzLmN1cnJlbnQucnVsZXMsXG4gICAgICAgICAgICAuLi4oaXNCb29sZWFuKF9wcm9wcy5jdXJyZW50LmRpc2FibGVkKVxuICAgICAgICAgICAgICAgID8geyBkaXNhYmxlZDogX3Byb3BzLmN1cnJlbnQuZGlzYWJsZWQgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdXBkYXRlTW91bnRlZCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5fZikge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZU1vdW50ZWQobmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChfc2hvdWxkVW5yZWdpc3RlckZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNsb25lT2JqZWN0KGdldChjb250cm9sLl9vcHRpb25zLmRlZmF1bHRWYWx1ZXMsIG5hbWUsIF9wcm9wcy5jdXJyZW50LmRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICAgICAgc2V0KGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgc2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAhaXNBcnJheUZpZWxkICYmIGNvbnRyb2wucmVnaXN0ZXIobmFtZSk7XG4gICAgICAgIF9wcmV2aW91c05hbWVSZWYuY3VycmVudCA9IG5hbWU7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAoaXNBcnJheUZpZWxkXG4gICAgICAgICAgICAgICAgPyBfc2hvdWxkVW5yZWdpc3RlckZpZWxkICYmICFjb250cm9sLl9zdGF0ZS5hY3Rpb25cbiAgICAgICAgICAgICAgICA6IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQpXG4gICAgICAgICAgICAgICAgPyBjb250cm9sLnVucmVnaXN0ZXIobmFtZSlcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU1vdW50ZWQobmFtZSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtuYW1lLCBjb250cm9sLCBpc0FycmF5RmllbGQsIHNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb250cm9sLl9zZXREaXNhYmxlZEZpZWxkKHtcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW2Rpc2FibGVkLCBuYW1lLCBjb250cm9sXSk7XG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZmllbGQsXG4gICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgZmllbGRTdGF0ZSxcbiAgICB9KSwgW2ZpZWxkLCBmb3JtU3RhdGUsIGZpZWxkU3RhdGVdKTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgYmFzZWQgb24gYHVzZUNvbnRyb2xsZXJgIGhvb2sgdG8gd29yayB3aXRoIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vjb250cm9sbGVyL2NvbnRyb2xsZXIpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ni1jb250cm9sbGVyLXRzLWp3eXp3KSDigKIgW1ZpZGVvXShodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PU4yVU5rX1VDVnlBKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHRoZSBwYXRoIG5hbWUgdG8gdGhlIGZvcm0gZmllbGQgdmFsdWUsIGFuZCB2YWxpZGF0aW9uIHJ1bGVzLlxuICpcbiAqIEByZXR1cm5zIHByb3ZpZGUgZmllbGQgaGFuZGxlciBmdW5jdGlvbnMsIGZpZWxkIGFuZCBmb3JtIHN0YXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtPEZvcm1WYWx1ZXM+KHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgICB0ZXN0OiBcIlwiXG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0+XG4gKiAgICAgICA8Q29udHJvbGxlclxuICogICAgICAgICBjb250cm9sPXtjb250cm9sfVxuICogICAgICAgICBuYW1lPVwidGVzdFwiXG4gKiAgICAgICAgIHJlbmRlcj17KHsgZmllbGQ6IHsgb25DaGFuZ2UsIG9uQmx1ciwgdmFsdWUsIHJlZiB9LCBmb3JtU3RhdGUsIGZpZWxkU3RhdGUgfSkgPT4gKFxuICogICAgICAgICAgIDw+XG4gKiAgICAgICAgICAgICA8aW5wdXRcbiAqICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfSAvLyBzZW5kIHZhbHVlIHRvIGhvb2sgZm9ybVxuICogICAgICAgICAgICAgICBvbkJsdXI9e29uQmx1cn0gLy8gbm90aWZ5IHdoZW4gaW5wdXQgaXMgdG91Y2hlZFxuICogICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9IC8vIHJldHVybiB1cGRhdGVkIHZhbHVlXG4gKiAgICAgICAgICAgICAgIHJlZj17cmVmfSAvLyBzZXQgcmVmIGZvciBmb2N1cyBtYW5hZ2VtZW50XG4gKiAgICAgICAgICAgICAvPlxuICogICAgICAgICAgICAgPHA+e2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCA/IFwic3VibWl0dGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICAgICAgICAgIDxwPntmaWVsZFN0YXRlLmlzVG91Y2hlZCA/IFwidG91Y2hlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgICAgICAgPC8+XG4gKiAgICAgICAgICl9XG4gKiAgICAgICAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBDb250cm9sbGVyID0gKHByb3BzKSA9PiBwcm9wcy5yZW5kZXIodXNlQ29udHJvbGxlcihwcm9wcykpO1xuXG5jb25zdCBmbGF0dGVuID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0VHlwZShvYmpba2V5XSkgJiYgb2JqW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZCA9IGZsYXR0ZW4ob2JqW2tleV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRLZXkgb2YgT2JqZWN0LmtleXMobmVzdGVkKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFtgJHtrZXl9LiR7bmVzdGVkS2V5fWBdID0gbmVzdGVkW25lc3RlZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5jb25zdCBIb29rRm9ybUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuSG9va0Zvcm1Db250ZXh0LmRpc3BsYXlOYW1lID0gJ0hvb2tGb3JtQ29udGV4dCc7XG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGZvcm0gY29udGV4dC4gdXNlRm9ybUNvbnRleHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMsIHdoZXJlIGl0IHdvdWxkIGJlY29tZSBpbmNvbnZlbmllbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhcyBhIHByb3AuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgRm9ybVByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybWNvbnRleHQpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny1mb3JtLWNvbnRleHQteXR1ZGkpXG4gKlxuICogQHJldHVybnMgcmV0dXJuIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgdXNlRm9ybUNvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEhvb2tGb3JtQ29udGV4dCk7XG4vKipcbiAqIEEgcHJvdmlkZXIgY29tcG9uZW50IHRoYXQgcHJvcGFnYXRlcyB0aGUgYHVzZUZvcm1gIG1ldGhvZHMgdG8gYWxsIGNoaWxkcmVuIGNvbXBvbmVudHMgdmlhIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QvdXNlQ29udGV4dCkgQVBJLiBUbyBiZSB1c2VkIHdpdGgge0BsaW5rIHVzZUZvcm1Db250ZXh0fS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybWNvbnRleHQpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny1mb3JtLWNvbnRleHQteXR1ZGkpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gYWxsIHVzZUZvcm0gbWV0aG9kc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybVByb3ZpZGVyIHsuLi5tZXRob2RzfSA+XG4gKiAgICAgICA8Zm9ybSBvblN1Ym1pdD17bWV0aG9kcy5oYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgICAgPE5lc3RlZElucHV0IC8+XG4gKiAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICAgIDwvZm9ybT5cbiAqICAgICA8L0Zvcm1Qcm92aWRlcj5cbiAqICAgKTtcbiAqIH1cbiAqXG4gKiAgZnVuY3Rpb24gTmVzdGVkSW5wdXQoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIgfSA9IHVzZUZvcm1Db250ZXh0KCk7IC8vIHJldHJpZXZlIGFsbCBob29rIG1ldGhvZHNcbiAqICAgcmV0dXJuIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJ0ZXN0XCIpfSAvPjtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBGb3JtUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCB3YXRjaCwgZ2V0VmFsdWVzLCBnZXRGaWVsZFN0YXRlLCBzZXRFcnJvciwgY2xlYXJFcnJvcnMsIHNldFZhbHVlLCB0cmlnZ2VyLCBmb3JtU3RhdGUsIHJlc2V0RmllbGQsIHJlc2V0LCBoYW5kbGVTdWJtaXQsIHVucmVnaXN0ZXIsIGNvbnRyb2wsIHJlZ2lzdGVyLCBzZXRGb2N1cywgc3Vic2NyaWJlLCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEhvb2tGb3JtQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICAgICAgd2F0Y2gsXG4gICAgICAgICAgICBnZXRWYWx1ZXMsXG4gICAgICAgICAgICBnZXRGaWVsZFN0YXRlLFxuICAgICAgICAgICAgc2V0RXJyb3IsXG4gICAgICAgICAgICBjbGVhckVycm9ycyxcbiAgICAgICAgICAgIHNldFZhbHVlLFxuICAgICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgICAgIHJlc2V0RmllbGQsXG4gICAgICAgICAgICByZXNldCxcbiAgICAgICAgICAgIGhhbmRsZVN1Ym1pdCxcbiAgICAgICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgICAgICBjb250cm9sLFxuICAgICAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgICAgICBzZXRGb2N1cyxcbiAgICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgfSksIFtcbiAgICAgICAgICAgIGNsZWFyRXJyb3JzLFxuICAgICAgICAgICAgY29udHJvbCxcbiAgICAgICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgICAgICAgICBnZXRWYWx1ZXMsXG4gICAgICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgICAgICByZWdpc3RlcixcbiAgICAgICAgICAgIHJlc2V0LFxuICAgICAgICAgICAgcmVzZXRGaWVsZCxcbiAgICAgICAgICAgIHNldEVycm9yLFxuICAgICAgICAgICAgc2V0Rm9jdXMsXG4gICAgICAgICAgICBzZXRWYWx1ZSxcbiAgICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICAgICAgd2F0Y2gsXG4gICAgICAgIF0pIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSG9va0Zvcm1Db250cm9sQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udHJvbCB9LCBjaGlsZHJlbikpKTtcbn07XG5cbmNvbnN0IFBPU1RfUkVRVUVTVCA9ICdwb3N0Jztcbi8qKlxuICogRm9ybSBjb21wb25lbnQgdG8gbWFuYWdlIHN1Ym1pc3Npb24uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdG8gc2V0dXAgc3VibWlzc2lvbiBkZXRhaWwuIHtAbGluayBGb3JtUHJvcHN9XG4gKlxuICogQHJldHVybnMgZm9ybSBjb21wb25lbnQgb3IgaGVhZGxlc3MgcmVuZGVyIHByb3AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybSBhY3Rpb249XCIvYXBpXCIgY29udHJvbD17Y29udHJvbH0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwibmFtZVwiKX0gLz5cbiAqICAgICAgIDxwPntlcnJvcnM/LnJvb3Q/LnNlcnZlciAmJiAnU2VydmVyIGVycm9yJ308L3A+XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvRm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBGb3JtKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgb25TdWJtaXQsIGNoaWxkcmVuLCBhY3Rpb24sIG1ldGhvZCA9IFBPU1RfUkVRVUVTVCwgaGVhZGVycywgZW5jVHlwZSwgb25FcnJvciwgcmVuZGVyLCBvblN1Y2Nlc3MsIHZhbGlkYXRlU3RhdHVzLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjb25zdCBzdWJtaXQgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gJyc7XG4gICAgICAgIGF3YWl0IGNvbnRyb2wuaGFuZGxlU3VibWl0KGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgbGV0IGZvcm1EYXRhSnNvbiA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBjb25zdCBmbGF0dGVuRm9ybVZhbHVlcyA9IGZsYXR0ZW4oY29udHJvbC5fZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmbGF0dGVuRm9ybVZhbHVlcykge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIGZsYXR0ZW5Gb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25TdWJtaXQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGFKc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIF0uc29tZSgodmFsdWUpID0+IHZhbHVlICYmIHZhbHVlLmluY2x1ZGVzKCdqc29uJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFN0cmluZyhhY3Rpb24pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oZW5jVHlwZSAmJiBlbmNUeXBlICE9PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7ICdDb250ZW50LVR5cGUnOiBlbmNUeXBlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPyBmb3JtRGF0YUpzb24gOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRlU3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAhdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzcG9uc2Uuc3RhdHVzIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBTdHJpbmcocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyAmJiBvblN1Y2Nlc3MoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgaWYgKGhhc0Vycm9yICYmIHByb3BzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuc2V0RXJyb3IoJ3Jvb3Quc2VydmVyJywge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlbmRlciA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXIoe1xuICAgICAgICBzdWJtaXQsXG4gICAgfSkpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCB7IG5vVmFsaWRhdGU6IG1vdW50ZWQsIGFjdGlvbjogYWN0aW9uLCBtZXRob2Q6IG1ldGhvZCwgZW5jVHlwZTogZW5jVHlwZSwgb25TdWJtaXQ6IHN1Ym1pdCwgLi4ucmVzdCB9LCBjaGlsZHJlbikpO1xufVxuXG5jb25zdCBGb3JtU3RhdGVTdWJzY3JpYmUgPSAoeyBjb250cm9sLCBkaXNhYmxlZCwgZXhhY3QsIG5hbWUsIHJlbmRlciwgfSkgPT4gcmVuZGVyKHVzZUZvcm1TdGF0ZSh7IGNvbnRyb2wsIG5hbWUsIGRpc2FibGVkLCBleGFjdCB9KSk7XG5cbnZhciBhcHBlbmRFcnJvcnMgPSAobmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcnMsIHR5cGUsIG1lc3NhZ2UpID0+IHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYVxuICAgID8ge1xuICAgICAgICAuLi5lcnJvcnNbbmFtZV0sXG4gICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAuLi4oZXJyb3JzW25hbWVdICYmIGVycm9yc1tuYW1lXS50eXBlcyA/IGVycm9yc1tuYW1lXS50eXBlcyA6IHt9KSxcbiAgICAgICAgICAgIFt0eXBlXTogbWVzc2FnZSB8fCB0cnVlLFxuICAgICAgICB9LFxuICAgIH1cbiAgICA6IHt9O1xuXG52YXIgY29udmVydFRvQXJyYXlQYXlsb2FkID0gKHZhbHVlKSA9PiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuXG52YXIgY3JlYXRlU3ViamVjdCA9ICgpID0+IHtcbiAgICBsZXQgX29ic2VydmVycyA9IFtdO1xuICAgIGNvbnN0IG5leHQgPSAodmFsdWUpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBfb2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSAob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgX29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgX29ic2VydmVycyA9IF9vYnNlcnZlcnMuZmlsdGVyKChvKSA9PiBvICE9PSBvYnNlcnZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIF9vYnNlcnZlcnMgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29ic2VydmVycztcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICB1bnN1YnNjcmliZSxcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZXh0cmFjdEZvcm1WYWx1ZXMoZmllbGRzU3RhdGUsIGZvcm1WYWx1ZXMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZHNTdGF0ZSkge1xuICAgICAgICBpZiAoZmllbGRzU3RhdGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTdGF0ZSA9IGZpZWxkc1N0YXRlW2tleV07XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZm9ybVZhbHVlc1trZXldO1xuICAgICAgICAgICAgaWYgKGZpZWxkU3RhdGUgJiYgaXNPYmplY3QoZmllbGRTdGF0ZSkgJiYgZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lc3RlZEZpZWxkc1N0YXRlID0gZXh0cmFjdEZvcm1WYWx1ZXMoZmllbGRTdGF0ZSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG5lc3RlZEZpZWxkc1N0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IG5lc3RlZEZpZWxkc1N0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkc1N0YXRlW2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxudmFyIGlzRW1wdHlPYmplY3QgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcblxudmFyIGlzRmlsZUlucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2ZpbGUnO1xuXG52YXIgaXNIVE1MRWxlbWVudCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNXZWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvd25lciA9IHZhbHVlID8gdmFsdWUub3duZXJEb2N1bWVudCA6IDA7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mXG4gICAgICAgIChvd25lciAmJiBvd25lci5kZWZhdWx0VmlldyA/IG93bmVyLmRlZmF1bHRWaWV3LkhUTUxFbGVtZW50IDogSFRNTEVsZW1lbnQpKTtcbn07XG5cbnZhciBpc011bHRpcGxlU2VsZWN0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYHNlbGVjdC1tdWx0aXBsZWA7XG5cbnZhciBpc1JhZGlvSW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAncmFkaW8nO1xuXG52YXIgaXNSYWRpb09yQ2hlY2tib3ggPSAocmVmKSA9PiBpc1JhZGlvSW5wdXQocmVmKSB8fCBpc0NoZWNrQm94SW5wdXQocmVmKTtcblxudmFyIGxpdmUgPSAocmVmKSA9PiBpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLmlzQ29ubmVjdGVkO1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLTEpLmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoKVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgOiBpc0tleShwYXRoKVxuICAgICAgICAgICAgPyBbcGF0aF1cbiAgICAgICAgICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGF0aHMubGVuZ3RoID09PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIHBhdGhzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhdGhzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qga2V5ID0gcGF0aHNbaW5kZXhdO1xuICAgIGlmIChjaGlsZE9iamVjdCkge1xuICAgICAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSAwICYmXG4gICAgICAgICgoaXNPYmplY3QoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlPYmplY3QoY2hpbGRPYmplY3QpKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKSkge1xuICAgICAgICB1bnNldChvYmplY3QsIHBhdGhzLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBvYmplY3RIYXNGdW5jdGlvbiA9IChkYXRhKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBpc1RyYXZlcnNhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IChpc09iamVjdCh2YWx1ZSkgJiYgIW9iamVjdEhhc0Z1bmN0aW9uKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBtYXJrRmllbGRzRGlydHkoZGF0YSwgZmllbGRzID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgICBpZiAoaXNUcmF2ZXJzYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZpZWxkc1trZXldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgbWFya0ZpZWxkc0RpcnR5KHZhbHVlLCBmaWVsZHNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgZmllbGRzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5mdW5jdGlvbiBnZXREaXJ0eUZpZWxkcyhkYXRhLCBmb3JtVmFsdWVzLCBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMpIHtcbiAgICBpZiAoIWRpcnR5RmllbGRzRnJvbVZhbHVlcykge1xuICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMgPSBtYXJrRmllbGRzRGlydHkoZm9ybVZhbHVlcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICAgIGlmIChpc1RyYXZlcnNhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpIHx8IGlzUHJpbWl0aXZlKGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKSkge1xuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gbWFya0ZpZWxkc0RpcnR5KHZhbHVlLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0RGlydHlGaWVsZHModmFsdWUsIGlzTnVsbE9yVW5kZWZpbmVkKGZvcm1WYWx1ZXMpID8ge30gOiBmb3JtVmFsdWVzW2tleV0sIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1WYWx1ZSA9IGZvcm1WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gIWRlZXBFcXVhbCh2YWx1ZSwgZm9ybVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlydHlGaWVsZHNGcm9tVmFsdWVzO1xufVxuXG5jb25zdCBkZWZhdWx0UmVzdWx0ID0ge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbn07XG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcbnZhciBnZXRDaGVja2JveFZhbHVlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWVzLCBpc1ZhbGlkOiAhIXZhbHVlcy5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9uc1swXS5jaGVja2VkICYmICFvcHRpb25zWzBdLmRpc2FibGVkXG4gICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgZXhwZWN0ZWQgdG8gd29yayBpbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uYXR0cmlidXRlcyAmJiAhaXNVbmRlZmluZWQob3B0aW9uc1swXS5hdHRyaWJ1dGVzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9wdGlvbnNbMF0udmFsdWUpIHx8IG9wdGlvbnNbMF0udmFsdWUgPT09ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IG9wdGlvbnNbMF0udmFsdWUsIGlzVmFsaWQ6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICA6IGRlZmF1bHRSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xufTtcblxudmFyIGdldEZpZWxkVmFsdWVBcyA9ICh2YWx1ZSwgeyB2YWx1ZUFzTnVtYmVyLCB2YWx1ZUFzRGF0ZSwgc2V0VmFsdWVBcyB9KSA9PiBpc1VuZGVmaW5lZCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiB2YWx1ZUFzTnVtYmVyXG4gICAgICAgID8gdmFsdWUgPT09ICcnXG4gICAgICAgICAgICA/IE5hTlxuICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gK3ZhbHVlXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICA6IHZhbHVlQXNEYXRlICYmIGlzU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgPyBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgICAgICAgIDogc2V0VmFsdWVBc1xuICAgICAgICAgICAgICAgID8gc2V0VmFsdWVBcyh2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuXG5jb25zdCBkZWZhdWx0UmV0dXJuID0ge1xuICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgIHZhbHVlOiBudWxsLFxufTtcbnZhciBnZXRSYWRpb1ZhbHVlID0gKG9wdGlvbnMpID0+IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICA/IG9wdGlvbnMucmVkdWNlKChwcmV2aW91cywgb3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxuICAgICAgICB9XG4gICAgICAgIDogcHJldmlvdXMsIGRlZmF1bHRSZXR1cm4pXG4gICAgOiBkZWZhdWx0UmV0dXJuO1xuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKF9mKSB7XG4gICAgY29uc3QgcmVmID0gX2YucmVmO1xuICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiByZWYuZmlsZXM7XG4gICAgfVxuICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xuICAgICAgICByZXR1cm4gWy4uLnJlZi5zZWxlY3RlZE9wdGlvbnNdLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpZWxkVmFsdWVBcyhpc1VuZGVmaW5lZChyZWYudmFsdWUpID8gX2YucmVmLnZhbHVlIDogcmVmLnZhbHVlLCBfZik7XG59XG5cbnZhciBnZXRSZXNvbHZlck9wdGlvbnMgPSAoZmllbGRzTmFtZXMsIF9maWVsZHMsIGNyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikgPT4ge1xuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgZmllbGQgJiYgc2V0KGZpZWxkcywgbmFtZSwgZmllbGQuX2YpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcml0ZXJpYU1vZGUsXG4gICAgICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdLFxuICAgICAgICBmaWVsZHMsXG4gICAgICAgIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gICAgfTtcbn07XG5cbnZhciBpc1JlZ2V4ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcblxudmFyIGdldFJ1bGVWYWx1ZSA9IChydWxlKSA9PiBpc1VuZGVmaW5lZChydWxlKVxuICAgID8gcnVsZVxuICAgIDogaXNSZWdleChydWxlKVxuICAgICAgICA/IHJ1bGUuc291cmNlXG4gICAgICAgIDogaXNPYmplY3QocnVsZSlcbiAgICAgICAgICAgID8gaXNSZWdleChydWxlLnZhbHVlKVxuICAgICAgICAgICAgICAgID8gcnVsZS52YWx1ZS5zb3VyY2VcbiAgICAgICAgICAgICAgICA6IHJ1bGUudmFsdWVcbiAgICAgICAgICAgIDogcnVsZTtcblxudmFyIGdldFZhbGlkYXRpb25Nb2RlcyA9IChtb2RlKSA9PiAoe1xuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICBpc09uQmx1cjogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQmx1cixcbiAgICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcbiAgICBpc09uVG91Y2g6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblRvdWNoZWQsXG59KTtcblxuY29uc3QgQVNZTkNfRlVOQ1RJT04gPSAnQXN5bmNGdW5jdGlvbic7XG52YXIgaGFzUHJvbWlzZVZhbGlkYXRpb24gPSAoZmllbGRSZWZlcmVuY2UpID0+ICEhZmllbGRSZWZlcmVuY2UgJiZcbiAgICAhIWZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlICYmXG4gICAgISEoKGlzRnVuY3Rpb24oZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgIGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSB8fFxuICAgICAgICAoaXNPYmplY3QoZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlKS5maW5kKCh2YWxpZGF0ZUZ1bmN0aW9uKSA9PiB2YWxpZGF0ZUZ1bmN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSkpO1xuXG52YXIgaGFzVmFsaWRhdGlvbiA9IChvcHRpb25zKSA9PiBvcHRpb25zLm1vdW50ICYmXG4gICAgKG9wdGlvbnMucmVxdWlyZWQgfHxcbiAgICAgICAgb3B0aW9ucy5taW4gfHxcbiAgICAgICAgb3B0aW9ucy5tYXggfHxcbiAgICAgICAgb3B0aW9ucy5tYXhMZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5taW5MZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5wYXR0ZXJuIHx8XG4gICAgICAgIG9wdGlvbnMudmFsaWRhdGUpO1xuXG52YXIgaXNXYXRjaGVkID0gKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpID0+ICFpc0JsdXJFdmVudCAmJlxuICAgIChfbmFtZXMud2F0Y2hBbGwgfHxcbiAgICAgICAgX25hbWVzLndhdGNoLmhhcyhuYW1lKSB8fFxuICAgICAgICBbLi4uX25hbWVzLndhdGNoXS5zb21lKCh3YXRjaE5hbWUpID0+IG5hbWUuc3RhcnRzV2l0aCh3YXRjaE5hbWUpICYmXG4gICAgICAgICAgICAvXlxcLlxcdysvLnRlc3QobmFtZS5zbGljZSh3YXRjaE5hbWUubGVuZ3RoKSkpKTtcblxuY29uc3QgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uID0gKGZpZWxkcywgYWN0aW9uLCBmaWVsZHNOYW1lcywgYWJvcnRFYXJseSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGZpZWxkc05hbWVzIHx8IE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoZmllbGRzLCBrZXkpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmN1cnJlbnRGaWVsZCB9ID0gZmllbGQ7XG4gICAgICAgICAgICBpZiAoX2YpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2YucmVmcyAmJiBfZi5yZWZzWzBdICYmIGFjdGlvbihfZi5yZWZzWzBdLCBrZXkpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfZi5yZWYgJiYgYWN0aW9uKF9mLnJlZiwgX2YubmFtZSkgJiYgIWFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChjdXJyZW50RmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihjdXJyZW50RmllbGQsIGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5cbmZ1bmN0aW9uIHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgbmFtZSkge1xuICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgaWYgKGVycm9yIHx8IGlzS2V5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHdoaWxlIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gbmFtZXMuam9pbignLicpO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICBjb25zdCBmb3VuZEVycm9yID0gZ2V0KGVycm9ycywgZmllbGROYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFBcnJheS5pc0FycmF5KGZpZWxkKSAmJiBuYW1lICE9PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmb3VuZEVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnJvb3QgJiYgZm91bmRFcnJvci5yb290LnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7ZmllbGROYW1lfS5yb290YCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZm91bmRFcnJvci5yb290LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICB9O1xufVxuXG52YXIgc2hvdWxkUmVuZGVyRm9ybVN0YXRlID0gKGZvcm1TdGF0ZURhdGEsIF9wcm94eUZvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlLCBpc1Jvb3QpID0+IHtcbiAgICB1cGRhdGVGb3JtU3RhdGUoZm9ybVN0YXRlRGF0YSk7XG4gICAgY29uc3QgeyBuYW1lLCAuLi5mb3JtU3RhdGUgfSA9IGZvcm1TdGF0ZURhdGE7XG4gICAgcmV0dXJuIChpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZSkgfHxcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPj0gT2JqZWN0LmtleXMoX3Byb3h5Rm9ybVN0YXRlKS5sZW5ndGggfHxcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5maW5kKChrZXkpID0+IF9wcm94eUZvcm1TdGF0ZVtrZXldID09PVxuICAgICAgICAgICAgKCFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbCkpKTtcbn07XG5cbnZhciBzaG91bGRTdWJzY3JpYmVCeU5hbWUgPSAobmFtZSwgc2lnbmFsTmFtZSwgZXhhY3QpID0+ICFuYW1lIHx8XG4gICAgIXNpZ25hbE5hbWUgfHxcbiAgICBuYW1lID09PSBzaWduYWxOYW1lIHx8XG4gICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLnNvbWUoKGN1cnJlbnROYW1lKSA9PiBjdXJyZW50TmFtZSAmJlxuICAgICAgICAoZXhhY3RcbiAgICAgICAgICAgID8gY3VycmVudE5hbWUgPT09IHNpZ25hbE5hbWVcbiAgICAgICAgICAgIDogY3VycmVudE5hbWUuc3RhcnRzV2l0aChzaWduYWxOYW1lKSB8fFxuICAgICAgICAgICAgICAgIHNpZ25hbE5hbWUuc3RhcnRzV2l0aChjdXJyZW50TmFtZSkpKTtcblxudmFyIHNraXBWYWxpZGF0aW9uID0gKGlzQmx1ckV2ZW50LCBpc1RvdWNoZWQsIGlzU3VibWl0dGVkLCByZVZhbGlkYXRlTW9kZSwgbW9kZSkgPT4ge1xuICAgIGlmIChtb2RlLmlzT25BbGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgbW9kZS5pc09uVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuICEoaXNUb3VjaGVkIHx8IGlzQmx1ckV2ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQmx1ciA6IG1vZGUuaXNPbkJsdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQ2hhbmdlIDogbW9kZS5pc09uQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdW5zZXRFbXB0eUFycmF5ID0gKHJlZiwgbmFtZSkgPT4gIWNvbXBhY3QoZ2V0KHJlZiwgbmFtZSkpLmxlbmd0aCAmJiB1bnNldChyZWYsIG5hbWUpO1xuXG52YXIgdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvciA9IChlcnJvcnMsIGVycm9yLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgZmllbGRBcnJheUVycm9ycyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChnZXQoZXJyb3JzLCBuYW1lKSk7XG4gICAgc2V0KGZpZWxkQXJyYXlFcnJvcnMsICdyb290JywgZXJyb3JbbmFtZV0pO1xuICAgIHNldChlcnJvcnMsIG5hbWUsIGZpZWxkQXJyYXlFcnJvcnMpO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuXG5mdW5jdGlvbiBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgcmVmLCB0eXBlID0gJ3ZhbGlkYXRlJykge1xuICAgIGlmIChpc1N0cmluZyhyZXN1bHQpIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0LmV2ZXJ5KGlzU3RyaW5nKSkgfHxcbiAgICAgICAgKGlzQm9vbGVhbihyZXN1bHQpICYmICFyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNTdHJpbmcocmVzdWx0KSA/IHJlc3VsdCA6ICcnLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGdldFZhbHVlQW5kTWVzc2FnZSA9ICh2YWxpZGF0aW9uRGF0YSkgPT4gaXNPYmplY3QodmFsaWRhdGlvbkRhdGEpICYmICFpc1JlZ2V4KHZhbGlkYXRpb25EYXRhKVxuICAgID8gdmFsaWRhdGlvbkRhdGFcbiAgICA6IHtcbiAgICAgICAgdmFsdWU6IHZhbGlkYXRpb25EYXRhLFxuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICB9O1xuXG52YXIgdmFsaWRhdGVGaWVsZCA9IGFzeW5jIChmaWVsZCwgZGlzYWJsZWRGaWVsZE5hbWVzLCBmb3JtVmFsdWVzLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sIGlzRmllbGRBcnJheSkgPT4ge1xuICAgIGNvbnN0IHsgcmVmLCByZWZzLCByZXF1aXJlZCwgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG1pbiwgbWF4LCBwYXR0ZXJuLCB2YWxpZGF0ZSwgbmFtZSwgdmFsdWVBc051bWJlciwgbW91bnQsIH0gPSBmaWVsZC5fZjtcbiAgICBjb25zdCBpbnB1dFZhbHVlID0gZ2V0KGZvcm1WYWx1ZXMsIG5hbWUpO1xuICAgIGlmICghbW91bnQgfHwgZGlzYWJsZWRGaWVsZE5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGlucHV0UmVmID0gcmVmcyA/IHJlZnNbMF0gOiByZWY7XG4gICAgY29uc3Qgc2V0Q3VzdG9tVmFsaWRpdHkgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiBpbnB1dFJlZi5yZXBvcnRWYWxpZGl0eSkge1xuICAgICAgICAgICAgaW5wdXRSZWYuc2V0Q3VzdG9tVmFsaWRpdHkoaXNCb29sZWFuKG1lc3NhZ2UpID8gJycgOiBtZXNzYWdlIHx8ICcnKTtcbiAgICAgICAgICAgIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVycm9yID0ge307XG4gICAgY29uc3QgaXNSYWRpbyA9IGlzUmFkaW9JbnB1dChyZWYpO1xuICAgIGNvbnN0IGlzQ2hlY2tCb3ggPSBpc0NoZWNrQm94SW5wdXQocmVmKTtcbiAgICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW8gfHwgaXNDaGVja0JveDtcbiAgICBjb25zdCBpc0VtcHR5ID0gKCh2YWx1ZUFzTnVtYmVyIHx8IGlzRmlsZUlucHV0KHJlZikpICYmXG4gICAgICAgIGlzVW5kZWZpbmVkKHJlZi52YWx1ZSkgJiZcbiAgICAgICAgaXNVbmRlZmluZWQoaW5wdXRWYWx1ZSkpIHx8XG4gICAgICAgIChpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLnZhbHVlID09PSAnJykgfHxcbiAgICAgICAgaW5wdXRWYWx1ZSA9PT0gJycgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgJiYgIWlucHV0VmFsdWUubGVuZ3RoKTtcbiAgICBjb25zdCBhcHBlbmRFcnJvcnNDdXJyeSA9IGFwcGVuZEVycm9ycy5iaW5kKG51bGwsIG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3IpO1xuICAgIGNvbnN0IGdldE1pbk1heE1lc3NhZ2UgPSAoZXhjZWVkTWF4LCBtYXhMZW5ndGhNZXNzYWdlLCBtaW5MZW5ndGhNZXNzYWdlLCBtYXhUeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXhMZW5ndGgsIG1pblR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbkxlbmd0aCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXhjZWVkTWF4ID8gbWF4TGVuZ3RoTWVzc2FnZSA6IG1pbkxlbmd0aE1lc3NhZ2U7XG4gICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsIG1lc3NhZ2UpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgaWYgKGlzRmllbGRBcnJheVxuICAgICAgICA/ICFBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpIHx8ICFpbnB1dFZhbHVlLmxlbmd0aFxuICAgICAgICA6IHJlcXVpcmVkICYmXG4gICAgICAgICAgICAoKCFpc1JhZGlvT3JDaGVja2JveCAmJiAoaXNFbXB0eSB8fCBpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQm9vbGVhbihpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoaXNDaGVja0JveCAmJiAhZ2V0Q2hlY2tib3hWYWx1ZShyZWZzKS5pc1ZhbGlkKSB8fFxuICAgICAgICAgICAgICAgIChpc1JhZGlvICYmICFnZXRSYWRpb1ZhbHVlKHJlZnMpLmlzVmFsaWQpKSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBtZXNzYWdlIH0gPSBpc1N0cmluZyhyZXF1aXJlZClcbiAgICAgICAgICAgID8geyB2YWx1ZTogISFyZXF1aXJlZCwgbWVzc2FnZTogcmVxdWlyZWQgfVxuICAgICAgICAgICAgOiBnZXRWYWx1ZUFuZE1lc3NhZ2UocmVxdWlyZWQpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNFbXB0eSAmJiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbikgfHwgIWlzTnVsbE9yVW5kZWZpbmVkKG1heCkpKSB7XG4gICAgICAgIGxldCBleGNlZWRNYXg7XG4gICAgICAgIGxldCBleGNlZWRNaW47XG4gICAgICAgIGNvbnN0IG1heE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXgpO1xuICAgICAgICBjb25zdCBtaW5PdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWluKTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSAmJiAhaXNOYU4oaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gcmVmLnZhbHVlQXNOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICAoaW5wdXRWYWx1ZSA/ICtpbnB1dFZhbHVlIDogaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1heE91dHB1dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNYXggPSB2YWx1ZU51bWJlciA+IG1heE91dHB1dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWluT3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlTnVtYmVyIDwgbWluT3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRlID0gcmVmLnZhbHVlQXNEYXRlIHx8IG5ldyBEYXRlKGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY29udmVydFRpbWVUb0RhdGUgPSAodGltZSkgPT4gbmV3IERhdGUobmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKSArICcgJyArIHRpbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNUaW1lID0gcmVmLnR5cGUgPT0gJ3RpbWUnO1xuICAgICAgICAgICAgY29uc3QgaXNXZWVrID0gcmVmLnR5cGUgPT0gJ3dlZWsnO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1heE91dHB1dC52YWx1ZSkgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IGlzVGltZVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRUaW1lVG9EYXRlKGlucHV0VmFsdWUpID4gY29udmVydFRpbWVUb0RhdGUobWF4T3V0cHV0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IGlzV2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFZhbHVlID4gbWF4T3V0cHV0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlRGF0ZSA+IG5ldyBEYXRlKG1heE91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluT3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPCBjb252ZXJ0VGltZVRvRGF0ZShtaW5PdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPCBtaW5PdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlIDwgbmV3IERhdGUobWluT3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4T3V0cHV0Lm1lc3NhZ2UsIG1pbk91dHB1dC5tZXNzYWdlLCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4pO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShlcnJvcltuYW1lXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChtYXhMZW5ndGggfHwgbWluTGVuZ3RoKSAmJlxuICAgICAgICAhaXNFbXB0eSAmJlxuICAgICAgICAoaXNTdHJpbmcoaW5wdXRWYWx1ZSkgfHwgKGlzRmllbGRBcnJheSAmJiBBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpKSkpIHtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heExlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xuICAgICAgICBjb25zdCBleGNlZWRNYXggPSAhaXNOdWxsT3JVbmRlZmluZWQobWF4TGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPiArbWF4TGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBjb25zdCBleGNlZWRNaW4gPSAhaXNOdWxsT3JVbmRlZmluZWQobWluTGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPCArbWluTGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZShleGNlZWRNYXgsIG1heExlbmd0aE91dHB1dC5tZXNzYWdlLCBtaW5MZW5ndGhPdXRwdXQubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0dGVybiAmJiAhaXNFbXB0eSAmJiBpc1N0cmluZyhpbnB1dFZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXR0ZXJuVmFsdWUsIG1lc3NhZ2UgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGlzUmVnZXgocGF0dGVyblZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5tYXRjaChwYXR0ZXJuVmFsdWUpKSB7XG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBtZXNzYWdlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgaW5wdXRSZWYpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy52YWxpZGF0ZSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkgJiYgIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IoYXdhaXQgdmFsaWRhdGVba2V5XShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKSwgaW5wdXRSZWYsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShrZXksIHZhbGlkYXRlRXJyb3IubWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0aW9uUmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXN0b21WYWxpZGl0eSh0cnVlKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gICAgcmVWYWxpZGF0ZU1vZGU6IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBzaG91bGRGb2N1c0Vycm9yOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUZvcm1Db250cm9sKHByb3BzID0ge30pIHtcbiAgICBsZXQgX29wdGlvbnMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICB9O1xuICAgIGxldCBfZm9ybVN0YXRlID0ge1xuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgICAgICBkaXJ0eUZpZWxkczoge30sXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IHt9LFxuICAgICAgICBlcnJvcnM6IF9vcHRpb25zLmVycm9ycyB8fCB7fSxcbiAgICAgICAgZGlzYWJsZWQ6IF9vcHRpb25zLmRpc2FibGVkIHx8IGZhbHNlLFxuICAgIH07XG4gICAgbGV0IF9maWVsZHMgPSB7fTtcbiAgICBsZXQgX2RlZmF1bHRWYWx1ZXMgPSBpc09iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSB8fCBpc09iamVjdChfb3B0aW9ucy52YWx1ZXMpXG4gICAgICAgID8gY2xvbmVPYmplY3QoX29wdGlvbnMuZGVmYXVsdFZhbHVlcyB8fCBfb3B0aW9ucy52YWx1ZXMpIHx8IHt9XG4gICAgICAgIDoge307XG4gICAgbGV0IF9mb3JtVmFsdWVzID0gX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlclxuICAgICAgICA/IHt9XG4gICAgICAgIDogY2xvbmVPYmplY3QoX2RlZmF1bHRWYWx1ZXMpO1xuICAgIGxldCBfc3RhdGUgPSB7XG4gICAgICAgIGFjdGlvbjogZmFsc2UsXG4gICAgICAgIG1vdW50OiBmYWxzZSxcbiAgICAgICAgd2F0Y2g6IGZhbHNlLFxuICAgICAgICBrZWVwSXNWYWxpZDogZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX25hbWVzID0ge1xuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICBkaXNhYmxlZDogbmV3IFNldCgpLFxuICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICBsZXQgZGVsYXlFcnJvckNhbGxiYWNrO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgY29uc3QgZGVmYXVsdFByb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgX3Byb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJveHlGb3JtU3RhdGUsXG4gICAgfTtcbiAgICBsZXQgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlID0ge1xuICAgICAgICAuLi5fcHJveHlGb3JtU3RhdGUsXG4gICAgfTtcbiAgICBjb25zdCBfc3ViamVjdHMgPSB7XG4gICAgICAgIGFycmF5OiBjcmVhdGVTdWJqZWN0KCksXG4gICAgICAgIHN0YXRlOiBjcmVhdGVTdWJqZWN0KCksXG4gICAgfTtcbiAgICBjb25zdCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycyA9IF9vcHRpb25zLmNyaXRlcmlhTW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbDtcbiAgICBjb25zdCBkZWJvdW5jZSA9IChjYWxsYmFjaykgPT4gKHdhaXQpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCB3YWl0KTtcbiAgICB9O1xuICAgIGNvbnN0IF9zZXRWYWxpZCA9IGFzeW5jIChzaG91bGRVcGRhdGVWYWxpZCkgPT4ge1xuICAgICAgICBpZiAoX3N0YXRlLmtlZXBJc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVWYWxpZCkpIHtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkO1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGlzRW1wdHlPYmplY3QoKGF3YWl0IF9ydW5TY2hlbWEoKSkuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZUlzVmFsaWRhdGluZyA9IChuYW1lcywgaXNWYWxpZGF0aW5nKSA9PiB7XG4gICAgICAgIGlmICghX29wdGlvbnMuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZGF0aW5nIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZGF0aW5nIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpKSB7XG4gICAgICAgICAgICAobmFtZXMgfHwgQXJyYXkuZnJvbShfbmFtZXMubW91bnQpKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUsIGlzVmFsaWRhdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiAhaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9zZXRGaWVsZEFycmF5ID0gKG5hbWUsIHZhbHVlcyA9IFtdLCBtZXRob2QsIGFyZ3MsIHNob3VsZFNldFZhbHVlcyA9IHRydWUsIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoYXJncyAmJiBtZXRob2QgJiYgIV9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBfc3RhdGUuYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJiBBcnJheS5pc0FycmF5KGdldChfZmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IG1ldGhvZChnZXQoX2ZpZWxkcywgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9maWVsZHMsIG5hbWUsIGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBtZXRob2QoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgdW5zZXRFbXB0eUFycmF5KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUudG91Y2hlZEZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hlZEZpZWxkcyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCB0b3VjaGVkRmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMgfHwgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmRpcnR5RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcyA9IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgdmFsdWVzKSxcbiAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkczogX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcyxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IF9mb3JtU3RhdGUuaXNWYWxpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVFcnJvcnMgPSAobmFtZSwgZXJyb3IpID0+IHtcbiAgICAgICAgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcik7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgX3NldEVycm9ycyA9IChlcnJvcnMpID0+IHtcbiAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVWYWxpZEFuZFZhbHVlID0gKG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzLCB2YWx1ZSwgcmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGdldChfZm9ybVZhbHVlcywgbmFtZSwgaXNVbmRlZmluZWQodmFsdWUpID8gZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSA6IHZhbHVlKTtcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAocmVmICYmIHJlZi5kZWZhdWx0Q2hlY2tlZCkgfHxcbiAgICAgICAgICAgICAgICBzaG91bGRTa2lwU2V0VmFsdWVBc1xuICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBzaG91bGRTa2lwU2V0VmFsdWVBcyA/IGRlZmF1bHRWYWx1ZSA6IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgX3N0YXRlLm1vdW50ICYmICFfc3RhdGUuYWN0aW9uICYmIF9zZXRWYWxpZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVUb3VjaEFuZERpcnR5ID0gKG5hbWUsIGZpZWxkVmFsdWUsIGlzQmx1ckV2ZW50LCBzaG91bGREaXJ0eSwgc2hvdWxkUmVuZGVyKSA9PiB7XG4gICAgICAgIGxldCBzaG91bGRVcGRhdGVGaWVsZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNQcmV2aW91c0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNCbHVyRXZlbnQgfHwgc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkgfHwgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ID0gX2Zvcm1TdGF0ZS5pc0RpcnR5O1xuICAgICAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvdXRwdXQuaXNEaXJ0eSA9IF9nZXREaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9IGlzUHJldmlvdXNEaXJ0eSAhPT0gb3V0cHV0LmlzRGlydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEZpZWxkUHJpc3RpbmUgPSBkZWVwRXF1YWwoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSwgZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ID0gISFnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaXNDdXJyZW50RmllbGRQcmlzdGluZVxuICAgICAgICAgICAgICAgICAgICA/IHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5kaXJ0eUZpZWxkcyA9IF9mb3JtU3RhdGUuZGlydHlGaWVsZHM7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKChfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ICE9PSAhaXNDdXJyZW50RmllbGRQcmlzdGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ByZXZpb3VzRmllbGRUb3VjaGVkID0gZ2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ByZXZpb3VzRmllbGRUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIGlzQmx1ckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRvdWNoZWRGaWVsZHMgPSBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUudG91Y2hlZEZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCAhPT0gaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkICYmIHNob3VsZFJlbmRlciAmJiBfc3ViamVjdHMuc3RhdGUubmV4dChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaG91bGRVcGRhdGVGaWVsZCA/IG91dHB1dCA6IHt9O1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkUmVuZGVyQnlFcnJvciA9IChuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkRXJyb3IgPSBnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVWYWxpZCA9IChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkgJiZcbiAgICAgICAgICAgIGlzQm9vbGVhbihpc1ZhbGlkKSAmJlxuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc1ZhbGlkICE9PSBpc1ZhbGlkO1xuICAgICAgICBpZiAoX29wdGlvbnMuZGVsYXlFcnJvciAmJiBlcnJvcikge1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gZGVib3VuY2UoKCkgPT4gdXBkYXRlRXJyb3JzKG5hbWUsIGVycm9yKSk7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2soX29wdGlvbnMuZGVsYXlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3IgPyAhZGVlcEVxdWFsKHByZXZpb3VzRmllbGRFcnJvciwgZXJyb3IpIDogcHJldmlvdXNGaWVsZEVycm9yKSB8fFxuICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHxcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZVZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4uKHNob3VsZFVwZGF0ZVZhbGlkICYmIGlzQm9vbGVhbihpc1ZhbGlkKSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfZm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh1cGRhdGVkRm9ybVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3J1blNjaGVtYSA9IGFzeW5jIChuYW1lKSA9PiB7XG4gICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcobmFtZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IF9vcHRpb25zLnJlc29sdmVyKF9mb3JtVmFsdWVzLCBfb3B0aW9ucy5jb250ZXh0LCBnZXRSZXNvbHZlck9wdGlvbnMobmFtZSB8fCBfbmFtZXMubW91bnQsIF9maWVsZHMsIF9vcHRpb25zLmNyaXRlcmlhTW9kZSwgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlID0gYXN5bmMgKG5hbWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCBfcnVuU2NoZW1hKG5hbWVzKTtcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhuYW1lcyk7XG4gICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9O1xuICAgIGNvbnN0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbiA9IGFzeW5jIChmaWVsZHMsIHNob3VsZE9ubHlDaGVja1ZhbGlkLCBjb250ZXh0ID0ge1xuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICB9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBfZiwgLi4uZmllbGRWYWx1ZSB9ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgaWYgKF9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRmllbGRBcnJheVJvb3QgPSBfbmFtZXMuYXJyYXkuaGFzKF9mLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Byb21pc2VGdW5jdGlvbiA9IGZpZWxkLl9mICYmIGhhc1Byb21pc2VWYWxpZGF0aW9uKGZpZWxkLl9mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUZ1bmN0aW9uICYmIF9wcm94eUZvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtfZi5uYW1lXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRFcnJvciA9IGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9uYW1lcy5kaXNhYmxlZCwgX2Zvcm1WYWx1ZXMsIHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uICYmICFzaG91bGRPbmx5Q2hlY2tWYWxpZCwgaXNGaWVsZEFycmF5Um9vdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2VGdW5jdGlvbiAmJiBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbX2YubmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZEVycm9yW19mLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkT25seUNoZWNrVmFsaWQgfHwgcHJvcHMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICFzaG91bGRPbmx5Q2hlY2tWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGdldChmaWVsZEVycm9yLCBfZi5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXNGaWVsZEFycmF5Um9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBfZi5uYW1lLCBmaWVsZEVycm9yW19mLm5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihmaWVsZFZhbHVlLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZhbGlkO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZVVubW91bnRlZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIF9uYW1lcy51bk1vdW50KSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGZpZWxkICYmXG4gICAgICAgICAgICAgICAgKGZpZWxkLl9mLnJlZnNcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZC5fZi5yZWZzLmV2ZXJ5KChyZWYpID0+ICFsaXZlKHJlZikpXG4gICAgICAgICAgICAgICAgICAgIDogIWxpdmUoZmllbGQuX2YucmVmKSkgJiZcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIF9uYW1lcy51bk1vdW50ID0gbmV3IFNldCgpO1xuICAgIH07XG4gICAgY29uc3QgX2dldERpcnR5ID0gKG5hbWUsIGRhdGEpID0+ICFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAobmFtZSAmJiBkYXRhICYmIHNldChfZm9ybVZhbHVlcywgbmFtZSwgZGF0YSksXG4gICAgICAgICAgICAhZGVlcEVxdWFsKGdldFZhbHVlcygpLCBfZGVmYXVsdFZhbHVlcykpO1xuICAgIGNvbnN0IF9nZXRXYXRjaCA9IChuYW1lcywgZGVmYXVsdFZhbHVlLCBpc0dsb2JhbCkgPT4gZ2VuZXJhdGVXYXRjaE91dHB1dChuYW1lcywgX25hbWVzLCB7XG4gICAgICAgIC4uLihfc3RhdGUubW91bnRcbiAgICAgICAgICAgID8gX2Zvcm1WYWx1ZXNcbiAgICAgICAgICAgIDogaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgID8gX2RlZmF1bHRWYWx1ZXNcbiAgICAgICAgICAgICAgICA6IGlzU3RyaW5nKG5hbWVzKVxuICAgICAgICAgICAgICAgICAgICA/IHsgW25hbWVzXTogZGVmYXVsdFZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUpLFxuICAgIH0sIGlzR2xvYmFsLCBkZWZhdWx0VmFsdWUpO1xuICAgIGNvbnN0IF9nZXRGaWVsZEFycmF5ID0gKG5hbWUpID0+IGNvbXBhY3QoZ2V0KF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDogX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIF9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIFtdKSA6IFtdKSk7XG4gICAgY29uc3Qgc2V0RmllbGRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBsZXQgZmllbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQuX2Y7XG4gICAgICAgICAgICBpZiAoZmllbGRSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAhZmllbGRSZWZlcmVuY2UuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBnZXRGaWVsZFZhbHVlQXModmFsdWUsIGZpZWxkUmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UucmVmKSAmJiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBbLi4uZmllbGRSZWZlcmVuY2UucmVmLm9wdGlvbnNdLmZvckVhY2goKG9wdGlvblJlZikgPT4gKG9wdGlvblJlZi5zZWxlY3RlZCA9IGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9uUmVmLnZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZFJlZmVyZW5jZS5yZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrQm94SW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5mb3JFYWNoKChjaGVja2JveFJlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tib3hSZWYuZGVmYXVsdENoZWNrZWQgfHwgIWNoZWNrYm94UmVmLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveFJlZi5jaGVja2VkID0gISFmaWVsZFZhbHVlLmZpbmQoKGRhdGEpID0+IGRhdGEgPT09IGNoZWNrYm94UmVmLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94UmVmLmNoZWNrZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPT09IGNoZWNrYm94UmVmLnZhbHVlIHx8ICEhZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5mb3JFYWNoKChyYWRpb1JlZikgPT4gKHJhZGlvUmVmLmNoZWNrZWQgPSByYWRpb1JlZi52YWx1ZSA9PT0gZmllbGRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlsZUlucHV0KGZpZWxkUmVmZXJlbmNlLnJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkUmVmZXJlbmNlLnJlZi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChvcHRpb25zLnNob3VsZERpcnR5IHx8IG9wdGlvbnMuc2hvdWxkVG91Y2gpICYmXG4gICAgICAgICAgICB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMuc2hvdWxkVG91Y2gsIG9wdGlvbnMuc2hvdWxkRGlydHksIHRydWUpO1xuICAgICAgICBvcHRpb25zLnNob3VsZFZhbGlkYXRlICYmIHRyaWdnZXIobmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRWYWx1ZXMgPSAobmFtZSwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShmaWVsZEtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdmFsdWVbZmllbGRLZXldO1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gbmFtZSArICcuJyArIGZpZWxkS2V5O1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgIChfbmFtZXMuYXJyYXkuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgaXNPYmplY3QoZmllbGRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZmllbGQgJiYgIWZpZWxkLl9mKSkgJiZcbiAgICAgICAgICAgICAgICAhaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMoZmllbGROYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXkgPSBfbmFtZXMuYXJyYXkuaGFzKG5hbWUpO1xuICAgICAgICBjb25zdCBjbG9uZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGNsb25lVmFsdWUpO1xuICAgICAgICBpZiAoaXNGaWVsZEFycmF5KSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fFxuICAgICAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc0RpcnR5IHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmRpcnR5RmllbGRzKSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgY2xvbmVWYWx1ZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZCAmJiAhZmllbGQuX2YgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKGNsb25lVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzV2F0Y2hlZChuYW1lLCBfbmFtZXMpKSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgbmFtZTogX3N0YXRlLm1vdW50ID8gbmFtZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBfc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGxldCBuYW1lID0gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGxldCBpc0ZpZWxkVmFsdWVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkID0gKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlzRmllbGRWYWx1ZVVwZGF0ZWQgPVxuICAgICAgICAgICAgICAgIE51bWJlci5pc05hTihmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpICYmIGlzTmFOKGZpZWxkVmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGVlcEVxdWFsKGZpZWxkVmFsdWUsIGdldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdGFyZ2V0LnR5cGVcbiAgICAgICAgICAgICAgICA/IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpXG4gICAgICAgICAgICAgICAgOiBnZXRFdmVudFZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID0gKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mKSAmJlxuICAgICAgICAgICAgICAgICFfb3B0aW9ucy5yZXNvbHZlciAmJlxuICAgICAgICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgIWZpZWxkLl9mLmRlcHMpIHx8XG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oaXNCbHVyRXZlbnQsIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBfZm9ybVN0YXRlLmlzU3VibWl0dGVkLCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0LCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCk7XG4gICAgICAgICAgICBjb25zdCB3YXRjaGVkID0gaXNXYXRjaGVkKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2Yub25CbHVyICYmIGZpZWxkLl9mLm9uQmx1cihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayAmJiBkZWxheUVycm9yQ2FsbGJhY2soMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQuX2Yub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5vbkNoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZFN0YXRlID0gdXBkYXRlVG91Y2hBbmREaXJ0eShuYW1lLCBmaWVsZFZhbHVlLCBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fCB3YXRjaGVkO1xuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmXG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX29wdGlvbnMubW9kZSA9PT0gJ29uQmx1cicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NldFZhbGlkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzaG91bGRSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBuYW1lLCAuLi4od2F0Y2hlZCA/IHt9IDogZmllbGRTdGF0ZSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmIHdhdGNoZWQgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9ydW5TY2hlbWEoW25hbWVdKTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdCA9IHNjaGVtYUVycm9yTG9va3VwKF9mb3JtU3RhdGUuZXJyb3JzLCBfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChlcnJvcnMsIF9maWVsZHMsIHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQubmFtZSB8fCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvckxvb2t1cFJlc3VsdC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGVycm9yTG9va3VwUmVzdWx0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGVycm9yID0gKGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9uYW1lcy5kaXNhYmxlZCwgX2Zvcm1WYWx1ZXMsIHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSlbbmFtZV07XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2YuZGVwcyAmJlxuICAgICAgICAgICAgICAgICAgICAoIUFycmF5LmlzQXJyYXkoZmllbGQuX2YuZGVwcykgfHwgZmllbGQuX2YuZGVwcy5sZW5ndGggPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKGZpZWxkLl9mLmRlcHMpO1xuICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlckJ5RXJyb3IobmFtZSwgaXNWYWxpZCwgZXJyb3IsIGZpZWxkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfZm9jdXNJbnB1dCA9IChyZWYsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBrZXkpICYmIHJlZi5mb2N1cykge1xuICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBjb25zdCB0cmlnZ2VyID0gYXN5bmMgKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgaXNWYWxpZDtcbiAgICAgICAgbGV0IHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gYXdhaXQgZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlKGlzVW5kZWZpbmVkKG5hbWUpID8gbmFtZSA6IGZpZWxkTmFtZXMpO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBuYW1lXG4gICAgICAgICAgICAgICAgPyAhZmllbGROYW1lcy5zb21lKChuYW1lKSA9PiBnZXQoZXJyb3JzLCBuYW1lKSlcbiAgICAgICAgICAgICAgICA6IGlzVmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IChhd2FpdCBQcm9taXNlLmFsbChmaWVsZE5hbWVzLm1hcChhc3luYyAoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkICYmIGZpZWxkLl9mID8geyBbZmllbGROYW1lXTogZmllbGQgfSA6IGZpZWxkKTtcbiAgICAgICAgICAgIH0pKSkuZXZlcnkoQm9vbGVhbik7XG4gICAgICAgICAgICAhKCF2YWxpZGF0aW9uUmVzdWx0ICYmICFfZm9ybVN0YXRlLmlzVmFsaWQpICYmIF9zZXRWYWxpZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IGlzVmFsaWQgPSBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgLi4uKCFpc1N0cmluZyhuYW1lKSB8fFxuICAgICAgICAgICAgICAgICgoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHwgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZClcbiAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgOiB7IG5hbWUgfSksXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMucmVzb2x2ZXIgfHwgIW5hbWUgPyB7IGlzVmFsaWQgfSA6IHt9KSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLnNob3VsZEZvY3VzICYmXG4gICAgICAgICAgICAhdmFsaWRhdGlvblJlc3VsdCAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIF9mb2N1c0lucHV0LCBuYW1lID8gZmllbGROYW1lcyA6IF9uYW1lcy5tb3VudCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgZ2V0VmFsdWVzID0gKGZpZWxkTmFtZXMsIGNvbmZpZykgPT4ge1xuICAgICAgICBsZXQgdmFsdWVzID0ge1xuICAgICAgICAgICAgLi4uKF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDogX2RlZmF1bHRWYWx1ZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBleHRyYWN0Rm9ybVZhbHVlcyhjb25maWcuZGlydHlGaWVsZHMgPyBfZm9ybVN0YXRlLmRpcnR5RmllbGRzIDogX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChmaWVsZE5hbWVzKVxuICAgICAgICAgICAgPyB2YWx1ZXNcbiAgICAgICAgICAgIDogaXNTdHJpbmcoZmllbGROYW1lcylcbiAgICAgICAgICAgICAgICA/IGdldCh2YWx1ZXMsIGZpZWxkTmFtZXMpXG4gICAgICAgICAgICAgICAgOiBmaWVsZE5hbWVzLm1hcCgobmFtZSkgPT4gZ2V0KHZhbHVlcywgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RmllbGRTdGF0ZSA9IChuYW1lLCBmb3JtU3RhdGUpID0+ICh7XG4gICAgICAgIGludmFsaWQ6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgaXNEaXJ0eTogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgIGVycm9yOiBnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6ICEhZ2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSksXG4gICAgICAgIGlzVG91Y2hlZDogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICB9KTtcbiAgICBjb25zdCBjbGVhckVycm9ycyA9IChuYW1lKSA9PiB7XG4gICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgIGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKS5mb3JFYWNoKChpbnB1dE5hbWUpID0+IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBpbnB1dE5hbWUpKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBuYW1lID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRFcnJvciA9IChuYW1lLCBlcnJvciwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZWYgPSAoZ2V0KF9maWVsZHMsIG5hbWUsIHsgX2Y6IHt9IH0pLl9mIHx8IHt9KS5yZWY7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSkgfHwge307XG4gICAgICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGVycm9yIG1lc3NhZ2VzIGVsc2V3aGVyZSBpbiB0aGUgb2JqZWN0IHRyZWUuXG4gICAgICAgIGNvbnN0IHsgcmVmOiBjdXJyZW50UmVmLCBtZXNzYWdlLCB0eXBlLCAuLi5yZXN0T2ZFcnJvclRyZWUgfSA9IGN1cnJlbnRFcnJvcjtcbiAgICAgICAgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCB7XG4gICAgICAgICAgICAuLi5yZXN0T2ZFcnJvclRyZWUsXG4gICAgICAgICAgICAuLi5lcnJvcixcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiYgcmVmICYmIHJlZi5mb2N1cyAmJiByZWYuZm9jdXMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHdhdGNoID0gKG5hbWUsIGRlZmF1bHRWYWx1ZSkgPT4gaXNGdW5jdGlvbihuYW1lKVxuICAgICAgICA/IF9zdWJqZWN0cy5zdGF0ZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogKHBheWxvYWQpID0+ICd2YWx1ZXMnIGluIHBheWxvYWQgJiZcbiAgICAgICAgICAgICAgICBuYW1lKF9nZXRXYXRjaCh1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZSksIHBheWxvYWQpLFxuICAgICAgICB9KVxuICAgICAgICA6IF9nZXRXYXRjaChuYW1lLCBkZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIGNvbnN0IF9zdWJzY3JpYmUgPSAocHJvcHMpID0+IF9zdWJqZWN0cy5zdGF0ZS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoZm9ybVN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3Vic2NyaWJlQnlOYW1lKHByb3BzLm5hbWUsIGZvcm1TdGF0ZS5uYW1lLCBwcm9wcy5leGFjdCkgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRSZW5kZXJGb3JtU3RhdGUoZm9ybVN0YXRlLCBwcm9wcy5mb3JtU3RhdGUgfHwgX3Byb3h5Rm9ybVN0YXRlLCBfc2V0Rm9ybVN0YXRlLCBwcm9wcy5yZVJlbmRlclJvb3QpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzOiBfZGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KS51bnN1YnNjcmliZTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSAocHJvcHMpID0+IHtcbiAgICAgICAgX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgLi4uX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4ucHJvcHMuZm9ybVN0YXRlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3N1YnNjcmliZSh7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGZvcm1TdGF0ZToge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRQcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi5wcm9wcy5mb3JtU3RhdGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVucmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIG5hbWUgPyBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkgOiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgIF9uYW1lcy5tb3VudC5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIF9uYW1lcy5hcnJheS5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIW9wdGlvbnMua2VlcEVycm9yICYmIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIW9wdGlvbnMua2VlcERpcnR5ICYmIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwVG91Y2hlZCAmJiB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwSXNWYWxpZGF0aW5nICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgJiZcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2RlZmF1bHRWYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgdmFsdWVzOiBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyksXG4gICAgICAgIH0pO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4uKCFvcHRpb25zLmtlZXBEaXJ0eSA/IHt9IDogeyBpc0RpcnR5OiBfZ2V0RGlydHkoKSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgICFvcHRpb25zLmtlZXBJc1ZhbGlkICYmIF9zZXRWYWxpZCgpO1xuICAgIH07XG4gICAgY29uc3QgX3NldERpc2FibGVkRmllbGQgPSAoeyBkaXNhYmxlZCwgbmFtZSwgfSkgPT4ge1xuICAgICAgICBpZiAoKGlzQm9vbGVhbihkaXNhYmxlZCkgJiYgX3N0YXRlLm1vdW50KSB8fFxuICAgICAgICAgICAgISFkaXNhYmxlZCB8fFxuICAgICAgICAgICAgX25hbWVzLmRpc2FibGVkLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBfbmFtZXMuZGlzYWJsZWQuaGFzKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9ICEhZGlzYWJsZWQ7XG4gICAgICAgICAgICBjb25zdCBkaXNhYmxlZFN0YXRlQ2hhbmdlZCA9IHdhc0Rpc2FibGVkICE9PSBpc0Rpc2FibGVkO1xuICAgICAgICAgICAgZGlzYWJsZWQgPyBfbmFtZXMuZGlzYWJsZWQuYWRkKG5hbWUpIDogX25hbWVzLmRpc2FibGVkLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIGRpc2FibGVkU3RhdGVDaGFuZ2VkICYmIF9zdGF0ZS5tb3VudCAmJiAhX3N0YXRlLmFjdGlvbiAmJiBfc2V0VmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZGlzYWJsZWRJc0RlZmluZWQgPSBpc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlZCkgfHwgaXNCb29sZWFuKF9vcHRpb25zLmRpc2FibGVkKTtcbiAgICAgICAgc2V0KF9maWVsZHMsIG5hbWUsIHtcbiAgICAgICAgICAgIC4uLihmaWVsZCB8fCB7fSksXG4gICAgICAgICAgICBfZjoge1xuICAgICAgICAgICAgICAgIC4uLihmaWVsZCAmJiBmaWVsZC5fZiA/IGZpZWxkLl9mIDogeyByZWY6IHsgbmFtZSB9IH0pLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgbW91bnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBfbmFtZXMubW91bnQuYWRkKG5hbWUpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIF9zZXREaXNhYmxlZEZpZWxkKHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICA6IF9vcHRpb25zLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgdHJ1ZSwgb3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLihkaXNhYmxlZElzRGVmaW5lZFxuICAgICAgICAgICAgICAgID8geyBkaXNhYmxlZDogb3B0aW9ucy5kaXNhYmxlZCB8fCBfb3B0aW9ucy5kaXNhYmxlZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMucHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICEhb3B0aW9ucy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgbWluOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5taW4pLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1heCksXG4gICAgICAgICAgICAgICAgICAgIG1pbkxlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5tYXhMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5wYXR0ZXJuKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgICAgICBvbkJsdXI6IG9uQ2hhbmdlLFxuICAgICAgICAgICAgcmVmOiAocmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcihuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmID0gaXNVbmRlZmluZWQocmVmLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYucXVlcnlTZWxlY3RvckFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYScpWzBdIHx8IHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkaW9PckNoZWNrYm94ID0gaXNSYWRpb09yQ2hlY2tib3goZmllbGRSZWYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZzID0gZmllbGQuX2YucmVmcyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWZzLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uID09PSBmaWVsZFJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRSZWYgPT09IGZpZWxkLl9mLnJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkLl9mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihyYWRpb09yQ2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVmcy5maWx0ZXIobGl2ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkgPyBbe31dIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogeyB0eXBlOiBmaWVsZFJlZi50eXBlLCBuYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHJlZjogZmllbGRSZWYgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCBmYWxzZSwgdW5kZWZpbmVkLCBmaWVsZFJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5fZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBvcHRpb25zLnNob3VsZFVucmVnaXN0ZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGlzTmFtZUluRmllbGRBcnJheShfbmFtZXMuYXJyYXksIG5hbWUpICYmIF9zdGF0ZS5hY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmFtZXMudW5Nb3VudC5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IF9mb2N1c0Vycm9yID0gKCkgPT4gX29wdGlvbnMuc2hvdWxkRm9jdXNFcnJvciAmJlxuICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgX2ZvY3VzSW5wdXQsIF9uYW1lcy5tb3VudCk7XG4gICAgY29uc3QgX2Rpc2FibGVGb3JtID0gKGRpc2FibGVkKSA9PiB7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oZGlzYWJsZWQpKSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IGRpc2FibGVkIH0pO1xuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIChyZWYsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICByZWYuZGlzYWJsZWQgPSBjdXJyZW50RmllbGQuX2YuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRGaWVsZC5fZi5yZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpZWxkLl9mLnJlZnMuZm9yRWFjaCgoaW5wdXRSZWYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFJlZi5kaXNhYmxlZCA9IGN1cnJlbnRGaWVsZC5fZi5kaXNhYmxlZCB8fCBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTdWJtaXQgPSAob25WYWxpZCwgb25JbnZhbGlkKSA9PiBhc3luYyAoZSkgPT4ge1xuICAgICAgICBsZXQgb25WYWxpZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnBlcnNpc3QgJiZcbiAgICAgICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRWYWx1ZXMgPSBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMsIHZhbHVlcyB9ID0gYXdhaXQgX3J1blNjaGVtYSgpO1xuICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZygpO1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICBmaWVsZFZhbHVlcyA9IGNsb25lT2JqZWN0KHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9uYW1lcy5kaXNhYmxlZC5zaXplKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoZmllbGRWYWx1ZXMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCAncm9vdCcpO1xuICAgICAgICBpZiAoaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLmVycm9ycykpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBlcnJvcnM6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uVmFsaWQoZmllbGRWYWx1ZXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25WYWxpZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob25JbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25JbnZhbGlkKHsgLi4uX2Zvcm1TdGF0ZS5lcnJvcnMgfSwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZm9jdXNFcnJvcigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChfZm9jdXNFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSAmJiAhb25WYWxpZEVycm9yLFxuICAgICAgICAgICAgc3VibWl0Q291bnQ6IF9mb3JtU3RhdGUuc3VibWl0Q291bnQgKyAxLFxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvblZhbGlkRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG9uVmFsaWRFcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVzZXRGaWVsZCA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgaWYgKGdldChfZmllbGRzLCBuYW1lKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG9wdGlvbnMuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKG5hbWUsIGNsb25lT2JqZWN0KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKG5hbWUsIG9wdGlvbnMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIGNsb25lT2JqZWN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcFRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgICAgID8gX2dldERpcnR5KG5hbWUsIGNsb25lT2JqZWN0KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpKVxuICAgICAgICAgICAgICAgICAgICA6IF9nZXREaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBFcnJvcikge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCAmJiBfc2V0VmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3Jlc2V0ID0gKGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkVmFsdWVzID0gZm9ybVZhbHVlcyA/IGNsb25lT2JqZWN0KGZvcm1WYWx1ZXMpIDogX2RlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGNvbnN0IGNsb25lVXBkYXRlZFZhbHVlcyA9IGNsb25lT2JqZWN0KHVwZGF0ZWRWYWx1ZXMpO1xuICAgICAgICBjb25zdCBpc0VtcHR5UmVzZXRWYWx1ZXMgPSBpc0VtcHR5T2JqZWN0KGZvcm1WYWx1ZXMpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBpc0VtcHR5UmVzZXRWYWx1ZXMgPyBfZGVmYXVsdFZhbHVlcyA6IGNsb25lVXBkYXRlZFZhbHVlcztcbiAgICAgICAgaWYgKCFrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgICAgICBfZGVmYXVsdFZhbHVlcyA9IHVwZGF0ZWRWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZWVwU3RhdGVPcHRpb25zLmtlZXBWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkc1RvQ2hlY2sgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgICAgICAgICAgLi4uX25hbWVzLm1vdW50LFxuICAgICAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBBcnJheS5mcm9tKGZpZWxkc1RvQ2hlY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRGlydHkgPSBnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGdldChfZm9ybVZhbHVlcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXQodmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaXJ0eSAmJiAhaXNVbmRlZmluZWQoZXhpc3RpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCh2YWx1ZXMsIGZpZWxkTmFtZSwgZXhpc3RpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzRGlydHkgJiYgIWlzVW5kZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZmllbGROYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNXZWIgJiYgaXNVbmRlZmluZWQoZm9ybVZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIF9uYW1lcy5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFJlZmVyZW5jZSA9IEFycmF5LmlzQXJyYXkoZmllbGQuX2YucmVmcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaWVsZC5fZi5yZWZzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGQuX2YucmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGZpZWxkUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gZmllbGRSZWZlcmVuY2UuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtlZXBTdGF0ZU9wdGlvbnMua2VlcEZpZWxkc1JlZikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKGZpZWxkTmFtZSwgZ2V0KHZhbHVlcywgZmllbGROYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9maWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZm9ybVZhbHVlcyA9IF9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXJcbiAgICAgICAgICAgICAgICA/IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgOiB7fVxuICAgICAgICAgICAgICAgIDogY2xvbmVPYmplY3QodmFsdWVzKTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfbmFtZXMgPSB7XG4gICAgICAgICAgICBtb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMgPyBfbmFtZXMubW91bnQgOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgICAgICBhcnJheTogbmV3IFNldCgpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaEFsbDogZmFsc2UsXG4gICAgICAgICAgICBmb2N1czogJycsXG4gICAgICAgIH07XG4gICAgICAgIF9zdGF0ZS5tb3VudCA9XG4gICAgICAgICAgICAhX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcElzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzIHx8XG4gICAgICAgICAgICAgICAgKCFfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyICYmICFpc0VtcHR5T2JqZWN0KHZhbHVlcykpO1xuICAgICAgICBfc3RhdGUud2F0Y2ggPSAhIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIF9zdGF0ZS5rZWVwSXNWYWxpZCA9ICEha2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNWYWxpZDtcbiAgICAgICAgX3N0YXRlLmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBDbGVhciBlcnJvcnMgc3luY2hyb25vdXNseSB0byBwcmV2ZW50IHZhbGlkYXRpb24gZXJyb3JzIG9uIHN1YnNlcXVlbnQgc3VibWlzc2lvbnNcbiAgICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgZm9ybS5yZXNldCgpIGNhdXNlcyB2YWxpZGF0aW9uIGVycm9ycyBvbiBzdWJzZXF1ZW50XG4gICAgICAgIC8vIHN1Ym1pc3Npb25zIGluIE5leHQuanMgMTYgd2l0aCBTZXJ2ZXIgQWN0aW9uc1xuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcEVycm9ycykge1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBzdWJtaXRDb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwU3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuc3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBpc0RpcnR5OiBpc0VtcHR5UmVzZXRWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA6ICEhKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFkZWVwRXF1YWwoZm9ybVZhbHVlcywgX2RlZmF1bHRWYWx1ZXMpKSxcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBkaXJ0eUZpZWxkczogaXNFbXB0eVJlc2V0VmFsdWVzXG4gICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIF9mb3JtVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiYgZm9ybVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuZGlydHlGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgdG91Y2hlZEZpZWxkczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwVG91Y2hlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICAgIGVycm9yczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRXJyb3JzID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0U3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczogX2RlZmF1bHRWYWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucykgPT4gX3Jlc2V0KGlzRnVuY3Rpb24oZm9ybVZhbHVlcylcbiAgICAgICAgPyBmb3JtVmFsdWVzKF9mb3JtVmFsdWVzKVxuICAgICAgICA6IGZvcm1WYWx1ZXMsIHsgLi4uX29wdGlvbnMucmVzZXRPcHRpb25zLCAuLi5rZWVwU3RhdGVPcHRpb25zIH0pO1xuICAgIGNvbnN0IHNldEZvY3VzID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZCAmJiBmaWVsZC5fZjtcbiAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGZpZWxkUmVmZXJlbmNlLnJlZnNcbiAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnNbMF1cbiAgICAgICAgICAgICAgICA6IGZpZWxkUmVmZXJlbmNlLnJlZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBzZXRUaW1lb3V0IHRvIGVuc3VyZSBmb2N1cyBoYXBwZW5zIGFmdGVyIGFueSBwZW5kaW5nIHN0YXRlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzZXRGb2N1cyBkb2Vzbid0IHdvcmsgaW1tZWRpYXRlbHkgYWZ0ZXIgc2V0RXJyb3JcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWYuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oZmllbGRSZWYuc2VsZWN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWYuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9zZXRGb3JtU3RhdGUgPSAodXBkYXRlZEZvcm1TdGF0ZSkgPT4ge1xuICAgICAgICBfZm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgIC4uLnVwZGF0ZWRGb3JtU3RhdGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBfcmVzZXREZWZhdWx0VmFsdWVzID0gKCkgPT4gaXNGdW5jdGlvbihfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSAmJlxuICAgICAgICBfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKCkudGhlbigodmFsdWVzKSA9PiB7XG4gICAgICAgICAgICByZXNldCh2YWx1ZXMsIF9vcHRpb25zLnJlc2V0T3B0aW9ucyk7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICByZWdpc3RlcixcbiAgICAgICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgICAgICBnZXRGaWVsZFN0YXRlLFxuICAgICAgICAgICAgaGFuZGxlU3VibWl0LFxuICAgICAgICAgICAgc2V0RXJyb3IsXG4gICAgICAgICAgICBfc3Vic2NyaWJlLFxuICAgICAgICAgICAgX3J1blNjaGVtYSxcbiAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcsXG4gICAgICAgICAgICBfZm9jdXNFcnJvcixcbiAgICAgICAgICAgIF9nZXRXYXRjaCxcbiAgICAgICAgICAgIF9nZXREaXJ0eSxcbiAgICAgICAgICAgIF9zZXRWYWxpZCxcbiAgICAgICAgICAgIF9zZXRGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3NldERpc2FibGVkRmllbGQsXG4gICAgICAgICAgICBfc2V0RXJyb3JzLFxuICAgICAgICAgICAgX2dldEZpZWxkQXJyYXksXG4gICAgICAgICAgICBfcmVzZXQsXG4gICAgICAgICAgICBfcmVzZXREZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgX3JlbW92ZVVubW91bnRlZCxcbiAgICAgICAgICAgIF9kaXNhYmxlRm9ybSxcbiAgICAgICAgICAgIF9zdWJqZWN0cyxcbiAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGdldCBfZmllbGRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfc3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfbmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX25hbWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9vcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHRyaWdnZXIsXG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgIHdhdGNoLFxuICAgICAgICBzZXRWYWx1ZSxcbiAgICAgICAgZ2V0VmFsdWVzLFxuICAgICAgICByZXNldCxcbiAgICAgICAgcmVzZXRGaWVsZCxcbiAgICAgICAgY2xlYXJFcnJvcnMsXG4gICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRGb2N1cyxcbiAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGZvcm1Db250cm9sOiBtZXRob2RzLFxuICAgIH07XG59XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9XG4gICAgY29uc3QgZCA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlLm5vdygpIDogcGVyZm9ybWFuY2Uubm93KCkgKiAxMDAwO1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAoKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYpIHwgMDtcbiAgICAgICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn07XG5cbnZhciBnZXRGb2N1c0ZpZWxkTmFtZSA9IChuYW1lLCBpbmRleCwgb3B0aW9ucyA9IHt9KSA9PiBvcHRpb25zLnNob3VsZEZvY3VzIHx8IGlzVW5kZWZpbmVkKG9wdGlvbnMuc2hvdWxkRm9jdXMpXG4gICAgPyBvcHRpb25zLmZvY3VzTmFtZSB8fFxuICAgICAgICBgJHtuYW1lfS4ke2lzVW5kZWZpbmVkKG9wdGlvbnMuZm9jdXNJbmRleCkgPyBpbmRleCA6IG9wdGlvbnMuZm9jdXNJbmRleH0uYFxuICAgIDogJyc7XG5cbnZhciBhcHBlbmRBdCA9IChkYXRhLCB2YWx1ZSkgPT4gW1xuICAgIC4uLmRhdGEsXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbl07XG5cbnZhciBmaWxsRW1wdHlBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKCkgPT4gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaW5zZXJ0KGRhdGEsIGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAgICAgICAuLi5kYXRhLnNsaWNlKGluZGV4KSxcbiAgICBdO1xufVxuXG52YXIgbW92ZUFycmF5QXQgPSAoZGF0YSwgZnJvbSwgdG8pID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQoZGF0YVt0b10pKSB7XG4gICAgICAgIGRhdGFbdG9dID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkYXRhLnNwbGljZSh0bywgMCwgZGF0YS5zcGxpY2UoZnJvbSwgMSlbMF0pO1xuICAgIHJldHVybiBkYXRhO1xufTtcblxudmFyIHByZXBlbmRBdCA9IChkYXRhLCB2YWx1ZSkgPT4gW1xuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKGRhdGEpLFxuXTtcblxuZnVuY3Rpb24gcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGluZGV4ZXMpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgdGVtcCA9IFsuLi5kYXRhXTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgICAgdGVtcC5zcGxpY2UoaW5kZXggLSBpLCAxKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFjdCh0ZW1wKS5sZW5ndGggPyB0ZW1wIDogW107XG59XG52YXIgcmVtb3ZlQXJyYXlBdCA9IChkYXRhLCBpbmRleCkgPT4gaXNVbmRlZmluZWQoaW5kZXgpXG4gICAgPyBbXVxuICAgIDogcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGNvbnZlcnRUb0FycmF5UGF5bG9hZChpbmRleCkuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcblxudmFyIHN3YXBBcnJheUF0ID0gKGRhdGEsIGluZGV4QSwgaW5kZXhCKSA9PiB7XG4gICAgW2RhdGFbaW5kZXhBXSwgZGF0YVtpbmRleEJdXSA9IFtkYXRhW2luZGV4Ql0sIGRhdGFbaW5kZXhBXV07XG59O1xuXG52YXIgdXBkYXRlQXQgPSAoZmllbGRWYWx1ZXMsIGluZGV4LCB2YWx1ZSkgPT4ge1xuICAgIGZpZWxkVmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHJldHVybiBmaWVsZFZhbHVlcztcbn07XG5cbi8qKlxuICogQSBjdXN0b20gaG9vayB0aGF0IGV4cG9zZXMgY29udmVuaWVudCBtZXRob2RzIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyB3aXRoIGEgbGlzdCBvZiBkeW5hbWljIGlucHV0cyB0aGF0IG5lZWQgdG8gYmUgYXBwZW5kZWQsIHVwZGF0ZWQsIHJlbW92ZWQgZXRjLiDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdXNlZmllbGRhcnJheS1zc3Vnbikg4oCiIFtWaWRlb10oaHR0cHM6Ly95b3V0dS5iZS80TXJiZkdTRlkyQSlcbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZmllbGRhcnJheSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXVzZWZpZWxkYXJyYXktc3N1Z24pXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdXNlRmllbGRBcnJheSBwcm9wc1xuICpcbiAqIEByZXR1cm5zIG1ldGhvZHMgLSBmdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSB3aXRoIHRoZSBGaWVsZCBBcnJheXMgKGR5bmFtaWMgaW5wdXRzKSB7QGxpbmsgVXNlRmllbGRBcnJheVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGNvbnRyb2wsIGhhbmRsZVN1Ym1pdCwgcmVzZXQsIHRyaWdnZXIsIHNldEVycm9yIH0gPSB1c2VGb3JtKHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgICB0ZXN0OiBbXVxuICogICAgIH1cbiAqICAgfSk7XG4gKiAgIGNvbnN0IHsgZmllbGRzLCBhcHBlbmQgfSA9IHVzZUZpZWxkQXJyYXkoe1xuICogICAgIGNvbnRyb2wsXG4gKiAgICAgbmFtZTogXCJ0ZXN0XCJcbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQoZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKSl9PlxuICogICAgICAge2ZpZWxkcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gKiAgICAgICAgICA8aW5wdXQga2V5PXtpdGVtLmlkfSB7Li4ucmVnaXN0ZXIoYHRlc3QuJHtpbmRleH0uZmlyc3ROYW1lYCl9ICAvPlxuICogICAgICAgKSl9XG4gKiAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXsoKSA9PiBhcHBlbmQoeyBmaXJzdE5hbWU6IFwiYmlsbFwiIH0pfT5cbiAqICAgICAgICAgYXBwZW5kXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRmllbGRBcnJheShwcm9wcykge1xuICAgIGNvbnN0IGZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2xDb250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gZm9ybUNvbnRyb2wsIG5hbWUsIGtleU5hbWUgPSAnaWQnLCBzaG91bGRVbnJlZ2lzdGVyLCBydWxlcywgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpKTtcbiAgICBjb25zdCBpZHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgIGNvbnN0IF9hY3Rpb25lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgY29udHJvbC5fbmFtZXMuYXJyYXkuYWRkKG5hbWUpO1xuICAgIFJlYWN0LnVzZU1lbW8oKCkgPT4gcnVsZXMgJiZcbiAgICAgICAgZmllbGRzLmxlbmd0aCA+PSAwICYmXG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXIobmFtZSwgcnVsZXMpLCBbY29udHJvbCwgbmFtZSwgZmllbGRzLmxlbmd0aCwgcnVsZXNdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGNvbnRyb2wuX3N1YmplY3RzLmFycmF5LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICh7IHZhbHVlcywgbmFtZTogZmllbGRBcnJheU5hbWUsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZEFycmF5TmFtZSA9PT0gbmFtZSB8fCAhZmllbGRBcnJheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldCh2YWx1ZXMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRGaWVsZHMoZmllbGRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZHMuY3VycmVudCA9IGZpZWxkVmFsdWVzLm1hcChnZW5lcmF0ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSkudW5zdWJzY3JpYmUsIFtjb250cm9sLCBuYW1lXSk7XG4gICAgY29uc3QgdXBkYXRlVmFsdWVzID0gUmVhY3QudXNlQ2FsbGJhY2soKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKSA9PiB7XG4gICAgICAgIF9hY3Rpb25lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgfSwgW2NvbnRyb2wsIG5hbWVdKTtcbiAgICBjb25zdCBhcHBlbmQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgYXBwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBhcHBlbmRBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBhcHBlbmRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMubGVuZ3RoIC0gMSwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gYXBwZW5kQXQoaWRzLmN1cnJlbnQsIGFwcGVuZFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGFwcGVuZEF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcHJlcGVuZCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBwcmVwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBwcmVwZW5kQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgcHJlcGVuZFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCAwLCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBwcmVwZW5kQXQoaWRzLmN1cnJlbnQsIHByZXBlbmRWYWx1ZS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBwcmVwZW5kQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSByZW1vdmVBcnJheUF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4KTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSByZW1vdmVBcnJheUF0KGlkcy5jdXJyZW50LCBpbmRleCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgICFBcnJheS5pc0FycmF5KGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpKSAmJlxuICAgICAgICAgICAgc2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcmVtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoaW5kZXgsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc2VydFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gaW5zZXJ0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCBpbnNlcnRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IGluc2VydChpZHMuY3VycmVudCwgaW5kZXgsIGluc2VydFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluc2VydCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgICAgICBhcmdCOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc3dhcCA9IChpbmRleEEsIGluZGV4QikgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIHN3YXBBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHN3YXBBcnJheUF0KGlkcy5jdXJyZW50LCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHN3YXBBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleEEsXG4gICAgICAgICAgICBhcmdCOiBpbmRleEIsXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmUgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICBtb3ZlQXJyYXlBdCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgZnJvbSwgdG8pO1xuICAgICAgICBtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgZnJvbSwgdG8pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogZnJvbSxcbiAgICAgICAgICAgIGFyZ0I6IHRvLFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGUgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHVwZGF0ZUF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCB1cGRhdGVWYWx1ZSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXS5tYXAoKGl0ZW0sIGkpID0+ICFpdGVtIHx8IGkgPT09IGluZGV4ID8gZ2VuZXJhdGVJZCgpIDogaWRzLmN1cnJlbnRbaV0pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHVwZGF0ZUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IHVwZGF0ZVZhbHVlLFxuICAgICAgICB9LCB0cnVlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCByZXBsYWNlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMubWFwKGdlbmVyYXRlSWQpO1xuICAgICAgICB1cGRhdGVWYWx1ZXMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLCAoZGF0YSkgPT4gZGF0YSwge30sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3N0YXRlLmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICBpc1dhdGNoZWQobmFtZSwgY29udHJvbC5fbmFtZXMpICYmXG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9hY3Rpb25lZC5jdXJyZW50ICYmXG4gICAgICAgICAgICAoIWdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLm1vZGUpLmlzT25TdWJtaXQgfHxcbiAgICAgICAgICAgICAgICBjb250cm9sLl9mb3JtU3RhdGUuaXNTdWJtaXR0ZWQpICYmXG4gICAgICAgICAgICAhZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMucmVWYWxpZGF0ZU1vZGUpLmlzT25TdWJtaXQpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sLl9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5fcnVuU2NoZW1hKFtuYW1lXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChyZXN1bHQuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFcnJvciA9IGdldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKCFlcnJvciAmJiBleGlzdGluZ0Vycm9yLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGlzdGluZ0Vycm9yLnR5cGUgIT09IGVycm9yLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRXJyb3IubWVzc2FnZSAhPT0gZXJyb3IubWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVycm9yICYmIGVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZiAmJlxuICAgICAgICAgICAgICAgICAgICAhKGdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKS5pc09uU3VibWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5tb2RlKS5pc09uU3VibWl0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBjb250cm9sLl9uYW1lcy5kaXNhYmxlZCwgY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsIGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgdHJ1ZSkudGhlbigoZXJyb3IpID0+ICFpc0VtcHR5T2JqZWN0KGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yKGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIGVycm9yLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWVzOiBjbG9uZU9iamVjdChjb250cm9sLl9mb3JtVmFsdWVzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oY29udHJvbC5fZmllbGRzLCAocmVmLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5fbmFtZXMuZm9jdXMgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgoY29udHJvbC5fbmFtZXMuZm9jdXMpICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9ICcnO1xuICAgICAgICBjb250cm9sLl9zZXRWYWxpZCgpO1xuICAgICAgICBfYWN0aW9uZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sIFtmaWVsZHMsIG5hbWUsIGNvbnRyb2xdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAhZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpICYmIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVNb3VudGVkID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXJcbiAgICAgICAgICAgICAgICA/IGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKVxuICAgICAgICAgICAgICAgIDogdXBkYXRlTW91bnRlZChuYW1lLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfSwgW25hbWUsIGNvbnRyb2wsIGtleU5hbWUsIHNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzd2FwOiBSZWFjdC51c2VDYWxsYmFjayhzd2FwLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIG1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKG1vdmUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcHJlcGVuZDogUmVhY3QudXNlQ2FsbGJhY2socHJlcGVuZCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBhcHBlbmQ6IFJlYWN0LnVzZUNhbGxiYWNrKGFwcGVuZCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICByZW1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKHJlbW92ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBpbnNlcnQ6IFJlYWN0LnVzZUNhbGxiYWNrKGluc2VydCQxLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHVwZGF0ZTogUmVhY3QudXNlQ2FsbGJhY2sodXBkYXRlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHJlcGxhY2U6IFJlYWN0LnVzZUNhbGxiYWNrKHJlcGxhY2UsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgZmllbGRzOiBSZWFjdC51c2VNZW1vKCgpID0+IGZpZWxkcy5tYXAoKGZpZWxkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgW2tleU5hbWVdOiBpZHMuY3VycmVudFtpbmRleF0gfHwgZ2VuZXJhdGVJZCgpLFxuICAgICAgICB9KSksIFtmaWVsZHMsIGtleU5hbWVdKSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIG1hbmFnZSB0aGUgZW50aXJlIGZvcm0uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm0pIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS1nZXQtc3RhcnRlZC10cy01a3NtbSkg4oCiIFtWaWRlb10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Sa1h2NEFYWENfNClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBmb3JtIGNvbmZpZ3VyYXRpb24gYW5kIHZhbGlkYXRpb24gcGFyYW1ldGVycy5cbiAqXG4gKiBAcmV0dXJucyBtZXRob2RzIC0gaW5kaXZpZHVhbCBmdW5jdGlvbnMgdG8gbWFuYWdlIHRoZSBmb3JtIHN0YXRlLiB7QGxpbmsgVXNlRm9ybVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGhhbmRsZVN1Ym1pdCwgd2F0Y2gsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICBjb25zb2xlLmxvZyh3YXRjaChcImV4YW1wbGVcIikpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgZGVmYXVsdFZhbHVlPVwidGVzdFwiIHsuLi5yZWdpc3RlcihcImV4YW1wbGVcIil9IC8+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZXhhbXBsZVJlcXVpcmVkXCIsIHsgcmVxdWlyZWQ6IHRydWUgfSl9IC8+XG4gKiAgICAgICB7ZXJyb3JzLmV4YW1wbGVSZXF1aXJlZCAmJiA8c3Bhbj5UaGlzIGZpZWxkIGlzIHJlcXVpcmVkPC9zcGFuPn1cbiAqICAgICAgIDxidXR0b24+U3VibWl0PC9idXR0b24+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZvcm0ocHJvcHMgPSB7fSkge1xuICAgIGNvbnN0IF9mb3JtQ29udHJvbCA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIGNvbnN0IF92YWx1ZXMgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICBjb25zdCBbZm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpLFxuICAgICAgICBpc1N1Ym1pdHRlZDogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgZGlydHlGaWVsZHM6IHt9LFxuICAgICAgICB0b3VjaGVkRmllbGRzOiB7fSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogcHJvcHMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0VmFsdWVzOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBwcm9wcy5kZWZhdWx0VmFsdWVzLFxuICAgIH0pO1xuICAgIGlmICghX2Zvcm1Db250cm9sLmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKHByb3BzLmZvcm1Db250cm9sKSB7XG4gICAgICAgICAgICBfZm9ybUNvbnRyb2wuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcy5mb3JtQ29udHJvbCxcbiAgICAgICAgICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZXMgJiYgIWlzRnVuY3Rpb24ocHJvcHMuZGVmYXVsdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5mb3JtQ29udHJvbC5yZXNldChwcm9wcy5kZWZhdWx0VmFsdWVzLCBwcm9wcy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBmb3JtQ29udHJvbCwgLi4ucmVzdCB9ID0gY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMpO1xuICAgICAgICAgICAgX2Zvcm1Db250cm9sLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2wgPSBfZm9ybUNvbnRyb2wuY3VycmVudC5jb250cm9sO1xuICAgIGNvbnRyb2wuX29wdGlvbnMgPSBwcm9wcztcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3ViID0gY29udHJvbC5fc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIGZvcm1TdGF0ZTogY29udHJvbC5fcHJveHlGb3JtU3RhdGUsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdXBkYXRlRm9ybVN0YXRlKHsgLi4uY29udHJvbC5fZm9ybVN0YXRlIH0pLFxuICAgICAgICAgICAgcmVSZW5kZXJSb290OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlRm9ybVN0YXRlKChkYXRhKSA9PiAoe1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGlzUmVhZHk6IHRydWUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29udHJvbC5fZm9ybVN0YXRlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH0sIFtjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IGNvbnRyb2wuX2Rpc2FibGVGb3JtKHByb3BzLmRpc2FibGVkKSwgW2NvbnRyb2wsIHByb3BzLmRpc2FibGVkXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLm1vZGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX29wdGlvbnMubW9kZSA9IHByb3BzLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLnJlVmFsaWRhdGVNb2RlKSB7XG4gICAgICAgICAgICBjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlID0gcHJvcHMucmVWYWxpZGF0ZU1vZGU7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbCwgcHJvcHMubW9kZSwgcHJvcHMucmVWYWxpZGF0ZU1vZGVdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMuZXJyb3JzKSB7XG4gICAgICAgICAgICBjb250cm9sLl9zZXRFcnJvcnMocHJvcHMuZXJyb3JzKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX2ZvY3VzRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBwcm9wcy5lcnJvcnNdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwcm9wcy5zaG91bGRVbnJlZ2lzdGVyICYmXG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNvbnRyb2wuX2dldFdhdGNoKCksXG4gICAgICAgICAgICB9KTtcbiAgICB9LCBbY29udHJvbCwgcHJvcHMuc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5KSB7XG4gICAgICAgICAgICBjb25zdCBpc0RpcnR5ID0gY29udHJvbC5fZ2V0RGlydHkoKTtcbiAgICAgICAgICAgIGlmIChpc0RpcnR5ICE9PSBmb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIGZvcm1TdGF0ZS5pc0RpcnR5XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocHJvcHMudmFsdWVzICYmICFkZWVwRXF1YWwocHJvcHMudmFsdWVzLCBfdmFsdWVzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldChwcm9wcy52YWx1ZXMsIHtcbiAgICAgICAgICAgICAgICBrZWVwRmllbGRzUmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX29wdGlvbnMucmVzZXRPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoISgoX2EgPSBjb250cm9sLl9vcHRpb25zLnJlc2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmtlZXBJc1ZhbGlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3NldFZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdmFsdWVzLmN1cnJlbnQgPSBwcm9wcy52YWx1ZXM7XG4gICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoKHN0YXRlKSA9PiAoeyAuLi5zdGF0ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldERlZmF1bHRWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBwcm9wcy52YWx1ZXNdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRyb2wuX3N0YXRlLm1vdW50KSB7XG4gICAgICAgICAgICBjb250cm9sLl9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sLl9zdGF0ZS53YXRjaCkge1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUud2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCk7XG4gICAgfSk7XG4gICAgX2Zvcm1Db250cm9sLmN1cnJlbnQuZm9ybVN0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXRQcm94eUZvcm1TdGF0ZShmb3JtU3RhdGUsIGNvbnRyb2wpLCBbY29udHJvbCwgZm9ybVN0YXRlXSk7XG4gICAgcmV0dXJuIF9mb3JtQ29udHJvbC5jdXJyZW50O1xufVxuXG4vKipcbiAqIFdhdGNoIGNvbXBvbmVudCB0aGF0IHN1YnNjcmliZXMgdG8gZm9ybSBmaWVsZCBjaGFuZ2VzIGFuZCByZS1yZW5kZXJzIHdoZW4gd2F0Y2hlZCBmaWVsZHMgdXBkYXRlLlxuICpcbiAqIEBwYXJhbSBjb250cm9sIC0gVGhlIGZvcm0gY29udHJvbCBvYmplY3QgZnJvbSB1c2VGb3JtXG4gKiBAcGFyYW0gbmFtZSAtIENhbiBiZSBmaWVsZCBuYW1lLCBhcnJheSBvZiBmaWVsZCBuYW1lcywgb3IgdW5kZWZpbmVkIHRvIHdhdGNoIHRoZSBlbnRpcmUgZm9ybVxuICogQHBhcmFtIGRpc2FibGVkIC0gRGlzYWJsZSBzdWJzY3JpcHRpb25cbiAqIEBwYXJhbSBleGFjdCAtIFdoZXRoZXIgdG8gd2F0Y2ggZXhhY3QgZmllbGQgbmFtZXMgb3Igbm90XG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBmaWVsZCBpcyBub3QgeWV0IHNldFxuICogQHBhcmFtIGNvbXB1dGUgLSBGdW5jdGlvbiB0byBjb21wdXRlIGRlcml2ZWQgdmFsdWVzIGZyb20gd2F0Y2hlZCBmaWVsZHNcbiAqIEBwYXJhbSByZW5kZXIgLSBUaGUgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB3YXRjaGVkIHZhbHVlcyBhbmQgcmV0dXJucyBSZWFjdE5vZGVcbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgY2FsbGluZyByZW5kZXIgZnVuY3Rpb24gd2l0aCB3YXRjaGVkIHZhbHVlc1xuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgYFdhdGNoYCBjb21wb25lbnQgb25seSByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWVzIG9mIGBmb29gLCBgYmFyYCwgYW5kIGBiYXoucXV4YCBjaGFuZ2UuXG4gKiBUaGUgdHlwZXMgb2YgYGZvb2AsIGBiYXJgLCBhbmQgYGJhei5xdXhgIGFyZSBwcmVjaXNlbHkgaW5mZXJyZWQuXG4gKlxuICogYGBgdHN4XG4gKiBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm0oKTtcbiAqXG4gKiA8V2F0Y2hcbiAqICAgY29udHJvbD17Y29udHJvbH1cbiAqICAgbmFtZXM9e1snZm9vJywgJ2JhcicsICdiYXoucXV4J119XG4gKiAgIHJlbmRlcj17KFtmb28sIGJhciwgYmF6X3F1eF0pID0+IDxkaXY+e2Zvb317YmFyfXtiYXpfcXV4fTwvZGl2Pn1cbiAqIC8+XG4gKiBgYGBcbiAqL1xuY29uc3QgV2F0Y2ggPSAocHJvcHMpID0+IHByb3BzLnJlbmRlcih1c2VXYXRjaCh7IG5hbWU6IHByb3BzLm5hbWVzLCAuLi5wcm9wcyB9KSk7XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIEZvcm0sIEZvcm1Qcm92aWRlciwgRm9ybVN0YXRlU3Vic2NyaWJlLCBXYXRjaCwgYXBwZW5kRXJyb3JzLCBjcmVhdGVGb3JtQ29udHJvbCwgZ2V0LCBzZXQsIHVzZUNvbnRyb2xsZXIsIHVzZUZpZWxkQXJyYXksIHVzZUZvcm0sIHVzZUZvcm1Db250ZXh0LCB1c2VGb3JtU3RhdGUsIHVzZVdhdGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiaXNDaGVja0JveElucHV0IiwiZWxlbWVudCIsInR5cGUiLCJpc0RhdGVPYmplY3QiLCJ2YWx1ZSIsIkRhdGUiLCJpc051bGxPclVuZGVmaW5lZCIsImlzT2JqZWN0VHlwZSIsImlzT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RXZlbnRWYWx1ZSIsImV2ZW50IiwidGFyZ2V0IiwiY2hlY2tlZCIsImdldE5vZGVQYXJlbnROYW1lIiwibmFtZSIsInN1YnN0cmluZyIsInNlYXJjaCIsImlzTmFtZUluRmllbGRBcnJheSIsIm5hbWVzIiwiaGFzIiwiaXNQbGFpbk9iamVjdCIsInRlbXBPYmplY3QiLCJwcm90b3R5cGVDb3B5IiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzV2ViIiwid2luZG93IiwiSFRNTEVsZW1lbnQiLCJkb2N1bWVudCIsImNsb25lT2JqZWN0IiwiZGF0YSIsImlzRmlsZUxpc3RJbnN0YW5jZSIsIkZpbGVMaXN0IiwiQmxvYiIsImNvcHkiLCJPYmplY3QiLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsImtleSIsImNhbGwiLCJpc0tleSIsInRlc3QiLCJpc1VuZGVmaW5lZCIsInZhbCIsInVuZGVmaW5lZCIsImNvbXBhY3QiLCJmaWx0ZXIiLCJCb29sZWFuIiwic3RyaW5nVG9QYXRoIiwiaW5wdXQiLCJyZXBsYWNlIiwic3BsaXQiLCJnZXQiLCJvYmplY3QiLCJwYXRoIiwiZGVmYXVsdFZhbHVlIiwicmVzdWx0IiwicmVkdWNlIiwiaXNCb29sZWFuIiwiaXNGdW5jdGlvbiIsInNldCIsImluZGV4IiwidGVtcFBhdGgiLCJsZW5ndGgiLCJsYXN0SW5kZXgiLCJuZXdWYWx1ZSIsIm9ialZhbHVlIiwiaXNOYU4iLCJFVkVOVFMiLCJCTFVSIiwiRk9DVVNfT1VUIiwiQ0hBTkdFIiwiVkFMSURBVElPTl9NT0RFIiwib25CbHVyIiwib25DaGFuZ2UiLCJvblN1Ym1pdCIsIm9uVG91Y2hlZCIsImFsbCIsIklOUFVUX1ZBTElEQVRJT05fUlVMRVMiLCJtYXgiLCJtaW4iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJwYXR0ZXJuIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsIkhvb2tGb3JtQ29udHJvbENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJ1c2VGb3JtQ29udHJvbENvbnRleHQiLCJ1c2VDb250ZXh0IiwiZ2V0UHJveHlGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJjb250cm9sIiwibG9jYWxQcm94eUZvcm1TdGF0ZSIsImlzUm9vdCIsImRlZmF1bHRWYWx1ZXMiLCJfZGVmYXVsdFZhbHVlcyIsImRlZmluZVByb3BlcnR5IiwiX2tleSIsIl9wcm94eUZvcm1TdGF0ZSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VGb3JtU3RhdGUiLCJwcm9wcyIsImZvcm1Db250cm9sIiwiZGlzYWJsZWQiLCJleGFjdCIsInVwZGF0ZUZvcm1TdGF0ZSIsInVzZVN0YXRlIiwiX2Zvcm1TdGF0ZSIsIl9sb2NhbFByb3h5Rm9ybVN0YXRlIiwidXNlUmVmIiwiaXNEaXJ0eSIsImlzTG9hZGluZyIsImRpcnR5RmllbGRzIiwidG91Y2hlZEZpZWxkcyIsInZhbGlkYXRpbmdGaWVsZHMiLCJpc1ZhbGlkYXRpbmciLCJpc1ZhbGlkIiwiZXJyb3JzIiwiX3N1YnNjcmliZSIsImN1cnJlbnQiLCJjYWxsYmFjayIsIl9zZXRWYWxpZCIsInVzZU1lbW8iLCJpc1N0cmluZyIsImdlbmVyYXRlV2F0Y2hPdXRwdXQiLCJfbmFtZXMiLCJmb3JtVmFsdWVzIiwiaXNHbG9iYWwiLCJ3YXRjaCIsImFkZCIsIm1hcCIsImZpZWxkTmFtZSIsIndhdGNoQWxsIiwiaXNQcmltaXRpdmUiLCJkZWVwRXF1YWwiLCJvYmplY3QxIiwib2JqZWN0MiIsIl9pbnRlcm5hbF92aXNpdGVkIiwiV2Vha1NldCIsImlzIiwiZ2V0VGltZSIsImtleXMxIiwia2V5cyIsImtleXMyIiwidmFsMSIsImluY2x1ZGVzIiwidmFsMiIsInVzZVdhdGNoIiwiY29tcHV0ZSIsIl9kZWZhdWx0VmFsdWUiLCJfY29tcHV0ZSIsIl9jb21wdXRlRm9ybVZhbHVlcyIsIl9wcmV2Q29udHJvbCIsIl9wcmV2TmFtZSIsInVwZGF0ZVZhbHVlIiwiX2dldFdhdGNoIiwiZ2V0Q3VycmVudE91dHB1dCIsInVzZUNhbGxiYWNrIiwidmFsdWVzIiwiX2Zvcm1WYWx1ZXMiLCJyZWZyZXNoVmFsdWUiLCJjb21wdXRlZEZvcm1WYWx1ZXMiLCJfcmVtb3ZlVW5tb3VudGVkIiwiY29udHJvbENoYW5nZWQiLCJwcmV2TmFtZSIsImNvbXB1dGVkT3V0cHV0IiwibmFtZUNoYW5nZWQiLCJzaG91bGRSZXR1cm5JbW1lZGlhdGUiLCJ1c2VDb250cm9sbGVyIiwic2hvdWxkVW5yZWdpc3RlciIsImlzQXJyYXlGaWVsZCIsImFycmF5IiwiZGVmYXVsdFZhbHVlTWVtbyIsIl9wcm9wcyIsIl9wcmV2aW91c05hbWVSZWYiLCJfcmVnaXN0ZXJQcm9wcyIsInJlZ2lzdGVyIiwicnVsZXMiLCJmaWVsZFN0YXRlIiwiZGVmaW5lUHJvcGVydGllcyIsImludmFsaWQiLCJlbnVtZXJhYmxlIiwiaXNUb3VjaGVkIiwiZXJyb3IiLCJyZWYiLCJlbG0iLCJmaWVsZCIsIl9maWVsZHMiLCJfZiIsImZvY3VzIiwic2VsZWN0Iiwic2V0Q3VzdG9tVmFsaWRpdHkiLCJtZXNzYWdlIiwicmVwb3J0VmFsaWRpdHkiLCJfc2hvdWxkVW5yZWdpc3RlckZpZWxkIiwiX29wdGlvbnMiLCJwcmV2aW91c05hbWUiLCJ1bnJlZ2lzdGVyIiwidXBkYXRlTW91bnRlZCIsIm1vdW50IiwiX3N0YXRlIiwiYWN0aW9uIiwiX3NldERpc2FibGVkRmllbGQiLCJDb250cm9sbGVyIiwicmVuZGVyIiwiZmxhdHRlbiIsIm9iaiIsIm91dHB1dCIsIm5lc3RlZCIsIm5lc3RlZEtleSIsIkhvb2tGb3JtQ29udGV4dCIsInVzZUZvcm1Db250ZXh0IiwiRm9ybVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJnZXRWYWx1ZXMiLCJnZXRGaWVsZFN0YXRlIiwic2V0RXJyb3IiLCJjbGVhckVycm9ycyIsInNldFZhbHVlIiwidHJpZ2dlciIsInJlc2V0RmllbGQiLCJyZXNldCIsImhhbmRsZVN1Ym1pdCIsInNldEZvY3VzIiwic3Vic2NyaWJlIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwiUE9TVF9SRVFVRVNUIiwiRm9ybSIsIm1ldGhvZHMiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsIm1ldGhvZCIsImhlYWRlcnMiLCJlbmNUeXBlIiwib25FcnJvciIsIm9uU3VjY2VzcyIsInZhbGlkYXRlU3RhdHVzIiwicmVzdCIsInN1Ym1pdCIsImhhc0Vycm9yIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImZvcm1EYXRhSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJfYSIsImZsYXR0ZW5Gb3JtVmFsdWVzIiwiYXBwZW5kIiwic2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEiLCJzb21lIiwicmVzcG9uc2UiLCJmZXRjaCIsIlN0cmluZyIsImJvZHkiLCJzdGF0dXMiLCJfc3ViamVjdHMiLCJzdGF0ZSIsIm5leHQiLCJpc1N1Ym1pdFN1Y2Nlc3NmdWwiLCJGcmFnbWVudCIsIm5vVmFsaWRhdGUiLCJGb3JtU3RhdGVTdWJzY3JpYmUiLCJhcHBlbmRFcnJvcnMiLCJ2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEiLCJ0eXBlcyIsImNvbnZlcnRUb0FycmF5UGF5bG9hZCIsImNyZWF0ZVN1YmplY3QiLCJfb2JzZXJ2ZXJzIiwib2JzZXJ2ZXIiLCJwdXNoIiwidW5zdWJzY3JpYmUiLCJvIiwib2JzZXJ2ZXJzIiwiZXh0cmFjdEZvcm1WYWx1ZXMiLCJmaWVsZHNTdGF0ZSIsImZpZWxkVmFsdWUiLCJuZXN0ZWRGaWVsZHNTdGF0ZSIsImlzRW1wdHlPYmplY3QiLCJpc0ZpbGVJbnB1dCIsImlzSFRNTEVsZW1lbnQiLCJvd25lciIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzTXVsdGlwbGVTZWxlY3QiLCJpc1JhZGlvSW5wdXQiLCJpc1JhZGlvT3JDaGVja2JveCIsImxpdmUiLCJpc0Nvbm5lY3RlZCIsImJhc2VHZXQiLCJ1cGRhdGVQYXRoIiwic2xpY2UiLCJpc0VtcHR5QXJyYXkiLCJ1bnNldCIsInBhdGhzIiwiY2hpbGRPYmplY3QiLCJvYmplY3RIYXNGdW5jdGlvbiIsImlzVHJhdmVyc2FibGUiLCJtYXJrRmllbGRzRGlydHkiLCJmaWVsZHMiLCJnZXREaXJ0eUZpZWxkcyIsImRpcnR5RmllbGRzRnJvbVZhbHVlcyIsImZvcm1WYWx1ZSIsImRlZmF1bHRSZXN1bHQiLCJ2YWxpZFJlc3VsdCIsImdldENoZWNrYm94VmFsdWUiLCJvcHRpb25zIiwib3B0aW9uIiwiYXR0cmlidXRlcyIsImdldEZpZWxkVmFsdWVBcyIsInZhbHVlQXNOdW1iZXIiLCJ2YWx1ZUFzRGF0ZSIsInNldFZhbHVlQXMiLCJOYU4iLCJkZWZhdWx0UmV0dXJuIiwiZ2V0UmFkaW9WYWx1ZSIsInByZXZpb3VzIiwiZ2V0RmllbGRWYWx1ZSIsImZpbGVzIiwicmVmcyIsInNlbGVjdGVkT3B0aW9ucyIsImdldFJlc29sdmVyT3B0aW9ucyIsImZpZWxkc05hbWVzIiwiY3JpdGVyaWFNb2RlIiwic2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiIsImlzUmVnZXgiLCJSZWdFeHAiLCJnZXRSdWxlVmFsdWUiLCJydWxlIiwic291cmNlIiwiZ2V0VmFsaWRhdGlvbk1vZGVzIiwibW9kZSIsImlzT25TdWJtaXQiLCJpc09uQmx1ciIsImlzT25DaGFuZ2UiLCJpc09uQWxsIiwiaXNPblRvdWNoIiwiQVNZTkNfRlVOQ1RJT04iLCJoYXNQcm9taXNlVmFsaWRhdGlvbiIsImZpZWxkUmVmZXJlbmNlIiwiZmluZCIsInZhbGlkYXRlRnVuY3Rpb24iLCJoYXNWYWxpZGF0aW9uIiwiaXNXYXRjaGVkIiwiaXNCbHVyRXZlbnQiLCJ3YXRjaE5hbWUiLCJzdGFydHNXaXRoIiwiaXRlcmF0ZUZpZWxkc0J5QWN0aW9uIiwiYWJvcnRFYXJseSIsImN1cnJlbnRGaWVsZCIsInNjaGVtYUVycm9yTG9va3VwIiwiam9pbiIsImZvdW5kRXJyb3IiLCJyb290IiwicG9wIiwic2hvdWxkUmVuZGVyRm9ybVN0YXRlIiwiZm9ybVN0YXRlRGF0YSIsInNob3VsZFN1YnNjcmliZUJ5TmFtZSIsInNpZ25hbE5hbWUiLCJjdXJyZW50TmFtZSIsInNraXBWYWxpZGF0aW9uIiwiaXNTdWJtaXR0ZWQiLCJyZVZhbGlkYXRlTW9kZSIsInVuc2V0RW1wdHlBcnJheSIsInVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IiLCJmaWVsZEFycmF5RXJyb3JzIiwiZ2V0VmFsaWRhdGVFcnJvciIsImV2ZXJ5IiwiZ2V0VmFsdWVBbmRNZXNzYWdlIiwidmFsaWRhdGlvbkRhdGEiLCJ2YWxpZGF0ZUZpZWxkIiwiZGlzYWJsZWRGaWVsZE5hbWVzIiwiaXNGaWVsZEFycmF5IiwiaW5wdXRWYWx1ZSIsImlucHV0UmVmIiwiaXNSYWRpbyIsImlzQ2hlY2tCb3giLCJpc0VtcHR5IiwiYXBwZW5kRXJyb3JzQ3VycnkiLCJiaW5kIiwiZ2V0TWluTWF4TWVzc2FnZSIsImV4Y2VlZE1heCIsIm1heExlbmd0aE1lc3NhZ2UiLCJtaW5MZW5ndGhNZXNzYWdlIiwibWF4VHlwZSIsIm1pblR5cGUiLCJleGNlZWRNaW4iLCJtYXhPdXRwdXQiLCJtaW5PdXRwdXQiLCJ2YWx1ZU51bWJlciIsInZhbHVlRGF0ZSIsImNvbnZlcnRUaW1lVG9EYXRlIiwidGltZSIsInRvRGF0ZVN0cmluZyIsImlzVGltZSIsImlzV2VlayIsIm1heExlbmd0aE91dHB1dCIsIm1pbkxlbmd0aE91dHB1dCIsInBhdHRlcm5WYWx1ZSIsIm1hdGNoIiwidmFsaWRhdGVFcnJvciIsInZhbGlkYXRpb25SZXN1bHQiLCJkZWZhdWx0T3B0aW9ucyIsInNob3VsZEZvY3VzRXJyb3IiLCJjcmVhdGVGb3JtQ29udHJvbCIsInN1Ym1pdENvdW50IiwiaXNSZWFkeSIsImlzU3VibWl0dGluZyIsImtlZXBJc1ZhbGlkIiwiU2V0IiwidW5Nb3VudCIsImRlbGF5RXJyb3JDYWxsYmFjayIsInRpbWVyIiwiZGVmYXVsdFByb3h5Rm9ybVN0YXRlIiwiX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlIiwic2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMiLCJkZWJvdW5jZSIsIndhaXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2hvdWxkVXBkYXRlVmFsaWQiLCJyZXNvbHZlciIsIl9ydW5TY2hlbWEiLCJfdXBkYXRlSXNWYWxpZGF0aW5nIiwiZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uIiwiZnJvbSIsImZvckVhY2giLCJfc2V0RmllbGRBcnJheSIsImFyZ3MiLCJzaG91bGRTZXRWYWx1ZXMiLCJzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSIsImZpZWxkVmFsdWVzIiwiYXJnQSIsImFyZ0IiLCJfZ2V0RGlydHkiLCJ1cGRhdGVFcnJvcnMiLCJfc2V0RXJyb3JzIiwidXBkYXRlVmFsaWRBbmRWYWx1ZSIsInNob3VsZFNraXBTZXRWYWx1ZUFzIiwiZGVmYXVsdENoZWNrZWQiLCJzZXRGaWVsZFZhbHVlIiwidXBkYXRlVG91Y2hBbmREaXJ0eSIsInNob3VsZERpcnR5Iiwic2hvdWxkUmVuZGVyIiwic2hvdWxkVXBkYXRlRmllbGQiLCJpc1ByZXZpb3VzRGlydHkiLCJpc0N1cnJlbnRGaWVsZFByaXN0aW5lIiwiaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCIsInNob3VsZFJlbmRlckJ5RXJyb3IiLCJwcmV2aW91c0ZpZWxkRXJyb3IiLCJkZWxheUVycm9yIiwidXBkYXRlZEZvcm1TdGF0ZSIsImNvbnRleHQiLCJleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUiLCJzaG91bGRPbmx5Q2hlY2tWYWxpZCIsInZhbGlkIiwiaXNGaWVsZEFycmF5Um9vdCIsImlzUHJvbWlzZUZ1bmN0aW9uIiwiZmllbGRFcnJvciIsIl9nZXRGaWVsZEFycmF5Iiwib3B0aW9uUmVmIiwic2VsZWN0ZWQiLCJjaGVja2JveFJlZiIsInJhZGlvUmVmIiwic2hvdWxkVG91Y2giLCJzaG91bGRWYWxpZGF0ZSIsInNldFZhbHVlcyIsImZpZWxkS2V5IiwiY2xvbmVWYWx1ZSIsImlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZCIsIk51bWJlciIsInZhbGlkYXRpb25Nb2RlQmVmb3JlU3VibWl0IiwidmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCIsInNob3VsZFNraXBWYWxpZGF0aW9uIiwiZGVwcyIsIndhdGNoZWQiLCJyZWFkT25seSIsInByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQiLCJlcnJvckxvb2t1cFJlc3VsdCIsIl9mb2N1c0lucHV0IiwiZmllbGROYW1lcyIsIlByb21pc2UiLCJzaG91bGRGb2N1cyIsImNvbmZpZyIsImlucHV0TmFtZSIsImN1cnJlbnRFcnJvciIsImN1cnJlbnRSZWYiLCJyZXN0T2ZFcnJvclRyZWUiLCJwYXlsb2FkIiwiX3NldEZvcm1TdGF0ZSIsInJlUmVuZGVyUm9vdCIsImRlbGV0ZSIsImtlZXBWYWx1ZSIsImtlZXBFcnJvciIsImtlZXBEaXJ0eSIsImtlZXBUb3VjaGVkIiwia2VlcElzVmFsaWRhdGluZyIsImtlZXBEZWZhdWx0VmFsdWUiLCJ3YXNEaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJkaXNhYmxlZFN0YXRlQ2hhbmdlZCIsImRpc2FibGVkSXNEZWZpbmVkIiwicHJvZ3Jlc3NpdmUiLCJmaWVsZFJlZiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyYWRpb09yQ2hlY2tib3giLCJfZm9jdXNFcnJvciIsIl9kaXNhYmxlRm9ybSIsIm9uVmFsaWQiLCJvbkludmFsaWQiLCJlIiwib25WYWxpZEVycm9yIiwicHJldmVudERlZmF1bHQiLCJwZXJzaXN0Iiwic2l6ZSIsIl9yZXNldCIsImtlZXBTdGF0ZU9wdGlvbnMiLCJ1cGRhdGVkVmFsdWVzIiwiY2xvbmVVcGRhdGVkVmFsdWVzIiwiaXNFbXB0eVJlc2V0VmFsdWVzIiwia2VlcERlZmF1bHRWYWx1ZXMiLCJrZWVwVmFsdWVzIiwia2VlcERpcnR5VmFsdWVzIiwiZmllbGRzVG9DaGVjayIsImV4aXN0aW5nVmFsdWUiLCJmb3JtIiwiY2xvc2VzdCIsImtlZXBGaWVsZHNSZWYiLCJrZWVwRXJyb3JzIiwia2VlcFN1Ym1pdENvdW50Iiwia2VlcElzU3VibWl0dGVkIiwia2VlcElzU3VibWl0U3VjY2Vzc2Z1bCIsInJlc2V0T3B0aW9ucyIsInNob3VsZFNlbGVjdCIsIl9yZXNldERlZmF1bHRWYWx1ZXMiLCJ0aGVuIiwiZ2VuZXJhdGVJZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJkIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEZvY3VzRmllbGROYW1lIiwiZm9jdXNOYW1lIiwiZm9jdXNJbmRleCIsImFwcGVuZEF0IiwiZmlsbEVtcHR5QXJyYXkiLCJpbnNlcnQiLCJtb3ZlQXJyYXlBdCIsInRvIiwic3BsaWNlIiwicHJlcGVuZEF0IiwicmVtb3ZlQXRJbmRleGVzIiwiaW5kZXhlcyIsImkiLCJ0ZW1wIiwicmVtb3ZlQXJyYXlBdCIsInNvcnQiLCJhIiwiYiIsInN3YXBBcnJheUF0IiwiaW5kZXhBIiwiaW5kZXhCIiwidXBkYXRlQXQiLCJ1c2VGaWVsZEFycmF5Iiwia2V5TmFtZSIsInNldEZpZWxkcyIsImlkcyIsIl9hY3Rpb25lZCIsImZpZWxkQXJyYXlOYW1lIiwidXBkYXRlVmFsdWVzIiwidXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMiLCJhcHBlbmRWYWx1ZSIsInByZXBlbmQiLCJwcmVwZW5kVmFsdWUiLCJyZW1vdmUiLCJpbnNlcnQkMSIsImluc2VydFZhbHVlIiwic3dhcCIsIm1vdmUiLCJ1cGRhdGUiLCJpdGVtIiwiZXhpc3RpbmdFcnJvciIsInVzZUZvcm0iLCJfZm9ybUNvbnRyb2wiLCJfdmFsdWVzIiwic3ViIiwiV2F0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs\n");

/***/ })

};
;